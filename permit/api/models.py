# generated by datamodel-codegen:
#   filename:  https://api.permit.io/v2/openapi.json
#   timestamp: 2023-05-31T09:43:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, BaseModel, EmailStr, Extra, Field, conint, constr
from typing_extensions import Literal


class APIHistoryEventFullRead(BaseModel):
    class Config:
        extra = Extra.allow

    request_body: Optional[bytes] = Field(None, title="Request Body")
    response_body: Optional[bytes] = Field(None, title="Response Body")
    timestamp: datetime = Field(..., title="Timestamp")
    method: str = Field(..., title="Method")
    path: str = Field(..., title="Path")
    success: bool = Field(..., title="Success")
    status: int = Field(..., title="Status")
    request_id: Optional[UUID] = Field(None, title="Request Id")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")
    id: UUID = Field(..., title="Id")


class APIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    timestamp: datetime = Field(..., title="Timestamp")
    method: str = Field(..., title="Method")
    path: str = Field(..., title="Path")
    success: bool = Field(..., title="Success")
    status: int = Field(..., title="Status")
    request_id: Optional[UUID] = Field(None, title="Request Id")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")
    id: UUID = Field(..., title="Id")


class APIKeyOwnerType(str, Enum):
    pdp_config = "pdp_config"
    member = "member"
    elements = "elements"


class APIKeyScopeRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the api_key belongs to.",
        title="Organization Id",
    )
    project_id: Optional[UUID] = Field(
        None,
        description="Unique id of the project that the api_key belongs to.",
        title="Project Id",
    )
    environment_id: Optional[UUID] = Field(
        None,
        description="Unique id of the environment that the api_key belongs to.",
        title="Environment Id",
    )


class AVPEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal["AVP"]] = Field("AVP", title="Engine")
    timestamp: datetime = Field(..., title="Timestamp")
    tenant: str = Field(..., title="Tenant")
    process_time_ms: Optional[int] = Field(None, title="Process Time Ms")
    input: Dict[str, Any] = Field(..., title="Input")
    result: Dict[str, Any] = Field(..., title="Result")


class ActionBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="a more descriptive name for the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this action represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class ActionBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="a more descriptive name for the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this action represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    id: UUID = Field(..., description="Unique id of the action", title="Id")
    key: Optional[str] = Field(None, description="action key", title="Key")


class ActionObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class ActivityDetailsObject(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title="Id")
    key: Optional[str] = Field(None, title="Key")
    kind: Optional[Literal["object"]] = Field("object", title="Kind")
    type: str = Field(..., title="Type")


class ActivityDetailsObjectData(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title="Id")
    key: Optional[str] = Field(None, title="Key")


class AddRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to assign to the role. If a permission is already granted to the role it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permissions",
    )


class AttributeType(str, Enum):
    bool = "bool"
    number = "number"
    string = "string"
    time = "time"
    array = "array"
    json = "json"


class AuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    context: Optional[Any] = Field(None, title="Context")
    action: Optional[str] = Field(None, title="Action")
    timestamp: datetime = Field(..., title="Timestamp")
    query: Optional[str] = Field(None, title="Query")
    user_key: Optional[str] = Field(None, title="User Key")
    user_email: Optional[str] = Field(None, title="User Email")
    user_name: Optional[str] = Field(None, title="User Name")
    resource_type: Optional[str] = Field(None, title="Resource Type")
    tenant: Optional[str] = Field(None, title="Tenant")
    decision: Optional[bool] = Field(None, title="Decision")
    reason: Optional[str] = Field(None, title="Reason")
    pdp_config_id: UUID = Field(..., title="Pdp Config Id")
    env_id: UUID = Field(..., title="Env Id")
    project_id: UUID = Field(..., title="Project Id")
    org_id: UUID = Field(..., title="Org Id")


class AuditLogSortKey(str, Enum):
    None_ = "None"
    timestamp = "timestamp"


class AuthMechanism(str, Enum):
    Bearer = "Bearer"
    Basic = "Basic"
    Headers = "Headers"


class AuthnMeUserRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["user"]] = Field("user", title="Actor Type")
    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    org_id: UUID = Field(..., title="Org Id")
    project_id: UUID = Field(..., title="Project Id")
    env_id: UUID = Field(..., title="Env Id")
    tenant_id: UUID = Field(..., title="Tenant Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="Given name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Family name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_onboarding: Optional[Literal[False]] = Field(False, title="Is Onboarding")
    onboarding_step: Optional[Literal["done"]] = Field("done", title="Onboarding Step")


class BulkRoleAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_created: Optional[int] = Field(0, title="Assignments Created")


class BulkRoleUnAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_removed: Optional[int] = Field(0, title="Assignments Removed")


class ConditionSetRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description="The userset that will be given permission, i.e: all the users matching this rule will be given the specified permission",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description='The permission that will be granted to the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="The resourceset that represents the resources that are granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*",
        title="Resource Set",
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title="Is Role",
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title="Is Resource",
    )


class ConditionSetRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the condition set rule", title="Id")
    key: str = Field(
        ...,
        description="A unique id by which Permit will identify this condition set rule.",
        title="Key",
    )
    user_set: str = Field(
        ...,
        description="the userset that is currently granted permissions, i.e: all the users matching this rule are granted the permission on the resourceset",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description="a permission that is currently granted to the userset *on* the resourceset.",
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="the resourceset that represents the resources that are currently granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*",
        title="Resource Set",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the condition set rule belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the condition set rule belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the condition set rule belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the condition set rule was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the condition set rule was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ConditionSetRuleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description="The userset that will be unassigned these permission, i.e: all the users matching this rule will lose the specified permission",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description='The permission that will be removed from the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="The resourceset that represents the resources that are no longer granted for access, i.e: all the resources matching this rule can no longer be accessed by the userset, and will be revoked the specified *permission*",
        title="Resource Set",
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title="Is Role",
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title="Is Resource",
    )


class ConditionSetType(str, Enum):
    userset = "userset"
    resourceset = "resourceset"


class ConditionSetUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class DataSourceEntry(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="Url source to query for data", title="Url")
    config: Optional[Dict[str, Any]] = Field(
        {},
        description="Suggested fetcher configuration (e.g. auth or method) to fetch data with",
        title="Config",
    )
    topics: Optional[List[str]] = Field(
        [], description="topics the data applies to", title="Topics"
    )
    dst_path: Optional[str] = Field(
        "", description="OPA data api path to store the document at", title="Dst Path"
    )
    save_method: Optional[str] = Field(
        "PUT",
        description="Method used to write into OPA - PUT/PATCH",
        title="Save Method",
    )


class DataSourceEntryWithPollingInterval(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="Url source to query for data", title="Url")
    data: Optional[Union[Dict[str, Any], List]] = Field(
        None,
        description="Data payload to embed within the data update (instead of having the client fetch it from the url).",
        title="Data",
    )
    config: Optional[Dict[str, Any]] = Field(
        None,
        description="Suggested fetcher configuration (e.g. auth or method) to fetch data with",
        title="Config",
    )
    topics: Optional[List[str]] = Field(
        ["policy_data"], description="topics the data applies to", title="Topics"
    )
    dst_path: Optional[str] = Field(
        "", description="OPA data api path to store the document at", title="Dst Path"
    )
    save_method: Optional[str] = Field(
        "PUT",
        description="Method used to write into OPA - PUT/PATCH",
        title="Save Method",
    )
    periodic_update_interval: Optional[float] = Field(
        None,
        description="Polling interval to refresh data from data source",
        title="Periodic Update Interval",
    )


class DerivedRoleRule(BaseModel):
    class Config:
        extra = Extra.allow

    relation: str = Field(..., title="Relation")
    related_resource: str = Field(..., title="Related Resource")
    related_role: str = Field(..., title="Related Role")


class DerivedRoleRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )


class DerivedRoleRuleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )


class DerivedRoleRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    role_id: UUID = Field(
        ...,
        description="the role id that needs to exist on the related resource (from the relation)",
        title="Role Id",
    )
    resource_id: UUID = Field(
        ...,
        description="the resource id that needs to exist on the related role (from the relation)",
        title="Resource Id",
    )
    relation_id: UUID = Field(
        ...,
        description="the relation id that needs to exist between the resource and the related resource",
        title="Relation Id",
    )
    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )


class DevLogin(BaseModel):
    class Config:
        extra = Extra.allow

    username: str = Field(
        ...,
        description="an email address from which to create a DEV MODE session",
        title="Username",
    )


class ElementsEnvTypeUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    roles_to_levels: Optional[Dict[str, List[str]]] = Field(
        None,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )


class ElementsPermissionLevel(str, Enum):
    LEVEL_1 = "LEVEL_1"
    LEVEL_2 = "LEVEL_2"
    LEVEL_3 = "LEVEL_3"
    LEVEL_4 = "LEVEL_4"
    HIDDEN = "HIDDEN"
    UNCONFIGURED = "UNCONFIGURED"


class PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings(BaseModel):
    class Config:
        extra = Extra.allow

    no_direct_roles_on_object: Optional[bool] = Field(
        False,
        description="If true, the derived role will not take action if the resource has any direct role",
        title="No Direct Roles On Object",
    )


class PermitBackendSchemasSchemaOpalDataDerivedRoleSettings(BaseModel):
    class Config:
        extra = Extra.allow

    superseded_by_direct_role: Optional[bool] = Field(
        False, title="Superseded By Direct Role"
    )


class DerivedRole(BaseModel):
    class Config:
        extra = Extra.allow

    conditions: Optional[str] = Field(None, title="Conditions")
    settings: PermitBackendSchemasSchemaOpalDataDerivedRoleSettings
    rules: List[DerivedRoleRule] = Field(..., title="Rules")


class DerivedRoleBlockEdit(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.parse_obj(
            {"no_direct_roles_on_object": False}
        ),
        description="the settings of the derived role",
        title="When",
    )
    users_with_role: Optional[List[DerivedRoleRuleCreate]] = Field(
        [], description="the rules of the derived role", title="Users With Role"
    )


class DerivedRoleBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.parse_obj(
            {"no_direct_roles_on_object": False}
        ),
        description="the settings of the derived role",
        title="When",
    )
    id: UUID = Field(..., description="The unique id of the derived_role", title="Id")
    users_with_role: Optional[List[DerivedRoleRuleRead]] = Field(
        [], description="the rules of the derived role", title="Users With Role"
    )


class ElementsRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        {},
        description="\n        A derived role defintion block, typically contained whithin a role definition.\n        The derived role is a role that is derived from the role definition.\n        ",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    permission_level: ElementsPermissionLevel


class ElementsType(str, Enum):
    user_management = "user_management"
    audit_log = "audit_log"
    approval_flow = "approval_flow"


class ElementsUserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9|@+\-\._]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )
    role: Optional[str] = Field(None, title="Role")


class ElementsUserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )


class ElementsUserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )


class EmbeddedLoginRequestOutput(BaseModel):
    class Config:
        extra = Extra.allow

    error: Optional[str] = Field(
        None,
        description="If the login request failed, this field will contain the error message",
        title="Error",
    )
    error_code: Optional[int] = Field(
        None,
        description="If the login request failed, this field will contain the error code",
        title="Error Code",
    )
    token: Optional[str] = Field(
        None,
        description="The auth token that lets your users login into permit elements",
        title="Token",
    )
    extra: Optional[str] = Field(
        None,
        description="Extra data that you can pass to the login request",
        title="Extra",
    )
    redirect_url: str = Field(
        ...,
        description="The full URL to which the user should be redirected in order to complete the login process",
        title="Redirect Url",
    )


class Engine(str, Enum):
    OPA = "OPA"
    AVP = "AVP"


class ConflictStrategy(str, Enum):
    fail = "fail"
    overwrite = "overwrite"


class EnvironmentCopyScopeFilters(BaseModel):
    class Config:
        extra = Extra.allow

    include: Optional[List[str]] = Field(
        [], description="Objects to include (use * as wildcard)", title="Include"
    )
    exclude: Optional[List[str]] = Field(
        [], description="Object to exclude (use * as wildcard)", title="Exclude"
    )


class EnvironmentObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class EnvironmentRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["environment"] = Field("environment", title="Scope")
    org_id: UUID = Field(..., title="Org Id")
    proj_id: UUID = Field(..., title="Proj Id")
    env_id: UUID = Field(..., title="Env Id")


class FailedInvite(BaseModel):
    class Config:
        extra = Extra.allow

    email: str = Field(..., title="Email")
    reason: str = Field(..., title="Reason")


class FullRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["full"] = Field("full", title="Scope")


class HttpMethods(Enum):
    get = "get"
    post = "post"
    put = "put"
    patch = "patch"
    head = "head"
    delete = "delete"


class IdentityRead(BaseModel):
    class Config:
        extra = Extra.allow

    user_id: str = Field(
        ...,
        description="Unique User Id of this identity in the identity provider (including the provider type)",
        title="User Id",
    )
    provider: str = Field(
        ...,
        description="The identity provider type this identity came from",
        title="Provider",
    )
    sub: str = Field(
        ...,
        description="Unique User Id of this identity in the identity provider (NOT including the provider type)",
        title="Sub",
    )
    email: EmailStr = Field(
        ..., description="Email connected to this account identity", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address connected to this account identity is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    auth0_info: Dict[str, Any] = Field(
        ...,
        description="Raw user info json coming from our identity provider and matching a specific account identity",
        title="Auth0 Info",
    )


class InviteAttemptResult(BaseModel):
    class Config:
        extra = Extra.allow

    invite_successful: Optional[bool] = Field(
        False, description="the invite code was accepted", title="Invite Successful"
    )
    invite_failed_reason: Optional[str] = Field(
        None,
        description="if the invite failed, the reason it failed",
        title="Invite Failed Reason",
    )


class InviteStatus(str, Enum):
    pending = "pending"
    accepted = "accepted"
    failed = "failed"
    canceled = "canceled"


class JwksObj(BaseModel):
    class Config:
        extra = Extra.allow

    keys: List[Dict[str, Any]] = Field(
        ..., description="The keys to match against the request headers", title="Keys"
    )


class Labels(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    version: str = Field(..., title="Version")


class LoginResult(BaseModel):
    class Config:
        extra = Extra.allow

    logged_in: bool = Field(
        ..., description="whether login was successful", title="Logged In"
    )
    expires_at: int = Field(
        ...,
        description="when will the login session expire (the unix timestamp in seconds)",
        title="Expires At",
    )
    active_org_id: Optional[UUID] = Field(
        None,
        description="the active organization on the session after the login",
        title="Active Org Id",
    )
    invite_attempt: Optional[InviteAttemptResult] = None


class MemberAccessLevel(str, Enum):
    admin = "admin"
    write = "write"
    read = "read"


class MemberAccessObj(str, Enum):
    org = "org"
    project = "project"
    env = "env"


class Methods(str, Enum):
    get = "get"
    post = "post"
    put = "put"
    patch = "patch"
    delete = "delete"
    head = "head"
    options = "options"


class OPADecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    decision_id: UUID = Field(..., title="Decision Id")
    labels: Labels
    run_id: Optional[UUID] = Field(None, title="Run Id")
    timestamp: datetime = Field(..., title="Timestamp")
    path: Optional[str] = Field(None, title="Path")
    input: Optional[Dict[str, Any]] = Field(None, title="Input")
    result: Optional[Dict[str, Any]] = Field(None, title="Result")


class OPALCommon(BaseModel):
    class Config:
        extra = Extra.allow

    FETCHING_CALLBACK_TIMEOUT: Optional[int] = Field(
        60, title="Fetching Callback Timeout"
    )


class OPALHttpFetcherConfig(BaseModel):
    class Config:
        extra = Extra.allow

    fetcher: Optional[str] = Field(
        None,
        description="indicates to OPAL client that it should use a custom FetcherProvider to fetch the data",
        title="Fetcher",
    )
    headers: Optional[Dict[str, str]] = Field(None, title="Headers")
    is_json: Optional[bool] = Field(True, title="Is Json")
    process_data: Optional[bool] = Field(True, title="Process Data")
    method: Optional[HttpMethods] = "get"
    data: Optional[Any] = Field(None, title="Data")


class OPALUpdateCallback(BaseModel):
    class Config:
        extra = Extra.allow

    callbacks: List[Union[str, List[Union[str, OPALHttpFetcherConfig]]]] = Field(
        ..., title="Callbacks"
    )


class OPALabels(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    version: str = Field(..., title="Version")


class OPAMetrics(BaseModel):
    class Config:
        extra = Extra.allow

    timer_rego_input_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Input Parse Ns"
    )
    timer_rego_query_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Query Parse Ns"
    )
    timer_rego_query_compile_ns: Optional[int] = Field(
        None, title="Timer Rego Query Compile Ns"
    )
    timer_rego_query_eval_ns: Optional[int] = Field(
        None, title="Timer Rego Query Eval Ns"
    )
    timer_rego_module_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Module Parse Ns"
    )
    timer_rego_module_compile_ns: Optional[int] = Field(
        None, title="Timer Rego Module Compile Ns"
    )
    timer_server_handler_ns: Optional[int] = Field(
        None, title="Timer Server Handler Ns"
    )


class OnboardingStep(str, Enum):
    create_organization = "create_organization"
    create_project = "create_project"
    create_resource = "create_resource"
    create_actions = "create_actions"
    assign_permissions = "assign_permissions"
    assign_user_roles = "assign_user_roles"
    connect_sdk = "connect_sdk"
    done = "done"


class OrgMemberUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    settings: Optional[Dict[str, Any]] = Field(
        None,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )
    onboarding_step: Optional[OnboardingStep] = Field(
        None, description="updates the onboarding step (optional)"
    )


class OrganizationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    name: constr(regex=r"^[A-Za-z0-9\.\-\_\ ]+$") = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class OrganizationObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class OrganizationRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the organization", title="Id")
    created_at: datetime = Field(
        ...,
        description="Date and time when the organization was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the organization was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class OrganizationReadWithAPIKey(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the organization", title="Id")
    created_at: datetime = Field(
        ...,
        description="Date and time when the organization was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the organization was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    api_key_id: Optional[UUID] = Field(None, title="Api Key Id")
    api_key_secret: Optional[str] = Field(None, title="Api Key Secret")


class OrganizationRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["organization"] = Field("organization", title="Scope")
    org_id: UUID = Field(..., title="Org Id")


class OrganizationUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[constr(regex=r"^[A-Za-z0-9\.\-\_\ ]+$")] = Field(
        None,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class PDPConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    name: Optional[str] = Field(None, title="Name")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the pdp_config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the pdp_config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the pdp_config belongs to.",
        title="Environment Id",
    )
    client_secret: str = Field(..., title="Client Secret")


class PDPContext(BaseModel):
    class Config:
        extra = Extra.allow

    customer_id: UUID = Field(..., title="Customer Id")
    client_id: str = Field(..., title="Client Id")
    backend_tier: AnyUrl = Field(..., title="Backend Tier")
    component: Optional[str] = Field("sidecar", title="Component")


class PDPInfo(BaseModel):
    class Config:
        extra = Extra.allow

    version: Optional[str] = Field(None, title="Version")
    os_name: Optional[str] = Field(None, title="Os Name")
    os_release: Optional[str] = Field(None, title="Os Release")
    os_version: Optional[str] = Field(None, title="Os Version")
    os_platform: Optional[str] = Field(None, title="Os Platform")
    os_machine: Optional[str] = Field(None, title="Os Machine")
    python_version: Optional[str] = Field(None, title="Python Version")
    python_implementation: Optional[str] = Field(None, title="Python Implementation")


class PDPOPAInfo(BaseModel):
    class Config:
        extra = Extra.allow

    version: Optional[str] = Field(None, title="Version")
    go_version: Optional[str] = Field(None, title="Go Version")
    platform: Optional[str] = Field(None, title="Platform")
    have_webassembly: Optional[bool] = Field(None, title="Have Webassembly")


class PDPState(BaseModel):
    class Config:
        extra = Extra.allow

    api_version: int = Field(..., title="Api Version")
    pdp: Optional[PDPInfo] = None
    opa: Optional[PDPOPAInfo] = None
    current_policy_hash: Optional[str] = Field(None, title="Current Policy Hash")
    most_recent_data: Optional[float] = Field(None, title="Most Recent Data")
    seen_sdks: Optional[List[str]] = Field(None, title="Seen Sdks")


class PDPStateUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    pdp_instance_id: UUID = Field(..., title="Pdp Instance Id")
    state: PDPState


class PaginatedResultAPIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIHistoryEventRead] = Field(
        ..., description="List of Api History Events", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultAuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[AuditLog] = Field(..., description="List of Audit Logs", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultOPADecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[OPADecisionLog] = Field(
        ..., description="List of Opa Decision Logs", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PdpConfigObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    name: str = Field(..., title="Name")


class PdpValues(BaseModel):
    class Config:
        extra = Extra.allow

    BACKEND_SERVICE_URL: str = Field(..., title="Backend Service Url")
    OPA_DECISION_LOG_INGRESS_ROUTE: str = Field(
        ..., title="Opa Decision Log Ingress Route"
    )
    OPA_DECISION_LOG_INGRESS_BACKEND_TIER_URL: str = Field(
        ..., title="Opa Decision Log Ingress Backend Tier Url"
    )


class Permission(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: MemberAccessObj
    access_level: MemberAccessLevel
    organization_key: Optional[str] = Field(None, title="Organization Key")
    project_key: Optional[str] = Field(None, title="Project Key")
    environment_key: Optional[str] = Field(None, title="Environment Key")
    organization_name: Optional[str] = Field(None, title="Organization Name")
    project_name: Optional[str] = Field(None, title="Project Name")
    environment_name: Optional[str] = Field(None, title="Environment Name")


class PermissionLevelRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the elements_env", title="Id")
    key: str = Field(
        ...,
        description="A URL-friendly name of the elements_env (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_env.",
        title="Key",
    )
    name: str = Field(..., title="Name")


class PolicyRepoStatus(str, Enum):
    invalid = "invalid"
    pending = "pending"
    valid = "valid"


class ProgrammingLanguage(Enum):
    javascript = "javascript"
    python = "python"
    dotnet = "dotnet"
    golang = "golang"
    ruby = "ruby"
    java = "java"
    kong_gateway = "kong_gateway"


class ProjectCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.",
        title="Key",
    )
    urn_namespace: Optional[constr(regex=r"[a-z0-9-]{2,}")] = Field(
        None,
        description="Optional namespace for URNs. If empty, URNs will be generated from project key.",
        title="Urn Namespace",
    )
    name: str = Field(..., description="The name of the project", title="Name")
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class ProjectObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class ProjectRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.",
        title="Key",
    )
    urn_namespace: Optional[constr(regex=r"[a-z0-9-]{2,}")] = Field(
        None,
        description="Optional namespace for URNs. If empty, URNs will be generated from project key.",
        title="Urn Namespace",
    )
    id: UUID = Field(..., description="Unique id of the project", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the project belongs to.",
        title="Organization Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the project was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the project was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the project", title="Name")
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class ProjectRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["project"] = Field("project", title="Scope")
    org_id: UUID = Field(..., title="Org Id")
    proj_id: UUID = Field(..., title="Proj Id")


class ProjectUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the project", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class RelationBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    resource_id: UUID = Field(
        ..., description="Unique id of the relation", title="Resource Id"
    )
    resource: str = Field(..., description="The resource key", title="Resource")


class RelationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.",
        title="Key",
    )
    name: str = Field(..., description="The name of the relation", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this relation respresents in your system",
        title="Description",
    )
    subject_resource: str = Field(
        ..., description="The subject resource ID or key", title="Subject Resource"
    )


class RelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this relation respresents in your system",
        title="Description",
    )
    subject_resource: str = Field(
        ..., description="The subject resource ID or key", title="Subject Resource"
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.",
        title="Key",
    )
    name: str = Field(..., description="The name of the relation", title="Name")
    id: UUID = Field(..., description="Unique id of the relation", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the relation belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the relation belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the relation belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the relation was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the relation was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    object_resource_id: UUID = Field(
        ..., description="The object resource id", title="Object Resource Id"
    )
    object_resource: str = Field(
        ..., description="The object resource key", title="Object Resource"
    )
    subject_resource_id: UUID = Field(
        ..., description="The subject resource id", title="Subject Resource Id"
    )


class RelationshipTupleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description="the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Subject",
    )
    relation: str = Field(
        ...,
        description="the relation to assign between the subject and object",
        title="Relation",
    )
    object: str = Field(
        ...,
        description="the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Object",
    )
    tenant: Optional[str] = Field(
        None,
        description="The tenant the subject and object belong to, if the resource instances don't exist yet, the tenant is required to create them. otherwise it is ignored",
        title="Tenant",
    )


class RelationshipTupleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description="the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Subject",
    )
    relation: str = Field(
        ...,
        description="the relation to assign between the subject and object",
        title="Relation",
    )
    object: str = Field(
        ...,
        description="the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Object",
    )


class RelationshipTupleObj(BaseModel):
    class Config:
        extra = Extra.allow

    subject_str: str = Field(..., title="Subject Str")
    relation_str: str = Field(..., title="Relation Str")
    object_str: str = Field(..., title="Object Str")


class RelationshipTupleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the relationship tuple", title="Id")
    subject: str = Field(
        ...,
        description="resource_key:resource_instance_key of the subject",
        title="Subject",
    )
    relation: str = Field(
        ..., description="key of the assigned relation", title="Relation"
    )
    object: str = Field(
        ...,
        description="resource_key:resource_instance_key of the object",
        title="Object",
    )
    tenant: str = Field(
        ...,
        description=""
    )
    subject_id: UUID = Field(
        ..., description="Unique id of the subject", title="Subject Id"
    )
    relation_id: UUID = Field(
        ..., description="Unique id of the relation", title="Relation Id"
    )
    object_id: UUID = Field(
        ..., description="Unique id of the object", title="Object Id"
    )
    tenant_id: UUID = Field(
        ..., description="Unique id of the tenant", title="Tenant Id"
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the relationship tuple belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the relationship tuple belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the relationship tuple belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the relationship tuple was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the relationship tuple was created (ISO_8601 format).",
        title="Updated At",
    )


class RemoveRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to remove from the role. If a permission is not found it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`,i.e: the "permission name".',
        title="Permissions",
    )


class ResourceActionCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.",
        title="Key",
    )
    name: str = Field(..., description="The name of the action", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )


class ResourceActionGroupCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.",
        title="Key",
    )
    name: str = Field(..., description="The name of the action group", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")


class ResourceActionGroupRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the action group", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the action group", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the action group belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the action group belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the action group belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the action group belongs to.",
        title="Resource Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the action group was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the action group was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceActionGroupUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the action group", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")


class ResourceActionRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the action", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the action", title="Id")
    permission_name: str = Field(
        ...,
        description="The name of the action, prefixed by the resource the action is acting upon.",
        title="Permission Name",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the action belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the action belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the action belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the action belongs to.",
        title="Resource Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the action was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the action was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceActionUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )


class ResourceAttributeCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.",
        title="Key",
    )
    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )


class ResourceAttributeRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the attribute", title="Id")
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the attribute belongs to.",
        title="Resource Id",
    )
    resource_key: str = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Resource Key",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the attribute belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the attribute belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the attribute belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the attribute was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the attribute was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    built_in: bool = Field(
        ...,
        description="Whether the attribute is built-in, and managed by the Permit system.",
        title="Built In",
    )


class ResourceAttributeUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    type: Optional[AttributeType] = Field(
        None,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )


class ResourceAttributes(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType
    key: str = Field(..., title="Key")


class ResourceInstanceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title="Key",
    )
    tenant: Optional[str] = Field(
        None,
        description="the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.",
        title="Tenant",
    )
    resource: str = Field(
        ...,
        description="the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.",
        title="Resource",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceInstanceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title="Key",
    )
    tenant: Optional[str] = Field(
        None,
        description="the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.",
        title="Tenant",
    )
    resource: str = Field(
        ...,
        description="the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.",
        title="Resource",
    )
    id: UUID = Field(..., description="Unique id of the resource instance", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the resource instance belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the resource instance belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the resource instance belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the resource instance was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the resource instance was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    resource_id: UUID = Field(
        ...,
        description="the id of the resource (type) of this resource instance.",
        title="Resource Id",
    )
    tenant_id: Optional[UUID] = Field(
        None,
        description="the id of the tenant of this resource instance.",
        title="Tenant Id",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceInstanceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class ResourceRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the role belongs to.",
        title="Resource Id",
    )
    resource: str = Field(
        ...,
        description="The unique resource key that the role belongs to.",
        title="Resource",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceRoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class ResourceTypeData(BaseModel):
    class Config:
        extra = Extra.allow

    actions: List[str] = Field(..., title="Actions")
    derived_roles: Dict[str, DerivedRole] = Field(..., title="Derived Roles")


class ResourceTypeObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    attributes: Optional[List[ResourceAttributes]] = Field(None, title="Attributes")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class RoleAssignmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )
    user: str = Field(
        ...,
        description="the user the role will be assigned to (accepts either the user id or the user key)",
        title="User",
    )


class RoleAssignmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the role assignment", title="Id")
    user: str = Field(..., description="the user the role is assigned to", title="User")
    role: str = Field(..., description="the role that is assigned", title="Role")
    tenant: Optional[str] = Field(
        None, description="the tenant the role is associated with", title="Tenant"
    )
    resource: Optional[str] = Field(
        None,
        description="the resource type the role is associated with",
        title="Resource",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with",
        title="Resource Instance",
    )
    resource_id: Optional[UUID] = Field(
        None, description="Unique id of the resource type", title="Resource Id"
    )
    resource_instance_id: Optional[UUID] = Field(
        None,
        description="Unique id of the resource instance",
        title="Resource Instance Id",
    )
    user_id: UUID = Field(..., description="Unique id of the user", title="User Id")
    role_id: UUID = Field(..., description="Unique id of the role", title="Role Id")
    tenant_id: UUID = Field(
        ..., description="Unique id of the tenant", title="Tenant Id"
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role assignment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role assignment belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role assignment belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role assignment was created (ISO_8601 format).",
        title="Created At",
    )


class RoleAssignmentRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )
    user: str = Field(
        ...,
        description="the user the role will be unassigned from (accepts either the user id or the user key)",
        title="User",
    )


class RoleBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class RoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class RoleData(BaseModel):
    class Config:
        extra = Extra.allow

    grants: Optional[Dict[str, List[str]]] = Field(None, title="Grants")


class RoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        {},
        description="\n        A derived role defintion block, typically contained whithin a role definition.\n        The derived role is a role that is derived from the role definition.\n        ",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class RoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class SSHAuthData(BaseModel):
    class Config:
        extra = Extra.allow

    auth_type: Optional[Literal["ssh"]] = Field("ssh", title="Auth Type")
    username: str = Field(..., description="SSH username", title="Username")
    public_key: Optional[str] = Field(
        None, description="SSH public key", title="Public Key"
    )
    private_key: str = Field(..., description="SSH private key", title="Private Key")


class TenantCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).",
        title="Key",
    )
    name: str = Field(
        ..., description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class TenantCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[TenantCreate] = Field(..., title="Operations")


class TenantCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Optional[Dict[str, List[str]]] = Field(
        None, title="Roleassignments"
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class TenantDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title="Idents")


class TenantDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class TenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the tenant", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the tenant belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the tenant belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the tenant belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the tenant was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the tenant was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    last_action_at: datetime = Field(
        ...,
        description="Date and time when the tenant was last active (ISO_8601 format). In other words, this is the last time a permission check was done on a resource belonging to this tenant.",
        title="Last Action At",
    )
    name: str = Field(
        ..., description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class TenantUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class UserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9|@+\-\._]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class UserCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title="Operations")


class UserCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Optional[Dict[str, List[str]]] = Field(
        None, title="Roleassignments"
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class UserDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title="Idents")


class UserDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserFELoginRequestInput(BaseModel):
    class Config:
        extra = Extra.allow

    user_jwt: str = Field(
        ...,
        description="jwt of the user for whom to generate a token, Note: the sub of this jwt must match the user key that exists in permit database",
        title="User Jwt",
    )
    tenant_id: str = Field(
        ...,
        description="ID or key of the tenant to which access is requested",
        title="Tenant Id",
    )


class UserLoginRequestInput(BaseModel):
    class Config:
        extra = Extra.allow

    user_id: str = Field(
        ...,
        description="ID or key of the user for whom to generate a token",
        title="User Id",
    )
    tenant_id: str = Field(
        ...,
        description="ID or key of the tenant to which access is requested",
        title="Tenant Id",
    )


class UserObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    email: Optional[str] = Field(None, title="Email")
    first_name: Optional[str] = Field(None, title="First Name")
    last_name: Optional[str] = Field(None, title="Last Name")
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    assigned_roles: Optional[List[str]] = Field(None, title="Assigned Roles")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class UserReplaceBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title="Operations")


class UserReplaceBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(..., description="the role that is assigned", title="Role")
    tenant: str = Field(
        ..., description="the tenant the role is associated with", title="Tenant"
    )


class UserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )


class UserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )


class UserStatus(str, Enum):
    active = "active"
    pending = "pending"


class UserUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class WebhookCreate(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="The url to POST the webhook to", title="Url")
    bearer_token: Optional[str] = Field(
        None,
        description="An optional bearer token to use to authenticate the request",
        title="Bearer Token",
    )


class WebhookRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the webhook", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the webhook belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the webhook belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the webhook belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the webhook was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the webhook was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    url: str = Field(..., description="The url to POST the webhook to", title="Url")


class WebhookUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    url: Optional[str] = Field(
        None, description="The url to POST the webhook to", title="Url"
    )
    bearer_token: Optional[str] = Field(
        None,
        description="An optional bearer token to use to authenticate the request",
        title="Bearer Token",
    )


class OpalCommonSchemasDataDataSourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    entries: Optional[List[DataSourceEntryWithPollingInterval]] = Field(
        [],
        description="list of data sources and how to fetch from them",
        title="Entries",
    )


class PermitBackendOpalApiDataDataSourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    entries: List[DataSourceEntry] = Field(
        ...,
        description="list of data sources and how to fetch from them",
        title="Entries",
    )


class APIKeyCreate(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: Optional[MemberAccessObj] = "env"
    access_level: Optional[MemberAccessLevel] = "admin"
    owner_type: Optional[APIKeyOwnerType] = "member"
    name: Optional[str] = Field(None, title="Name")


class ActivityDetailsList(BaseModel):
    class Config:
        extra = Extra.allow

    kind: Optional[Literal["list"]] = Field("list", title="Kind")
    type: str = Field(..., title="Type")
    items: List[ActivityDetailsObjectData] = Field(..., title="Items")


class ActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    timestamp: datetime = Field(..., title="Timestamp")
    activity_id: Optional[str] = Field(None, title="Activity Id")
    activity_description: Optional[str] = Field(None, title="Activity Description")
    activity_details: Optional[
        Dict[str, Union[ActivityDetailsObject, ActivityDetailsList]]
    ] = Field(None, title="Activity Details")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")


class AttributeBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what data this attribute will store",
        title="Description",
    )


class AttributeBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what data this attribute will store",
        title="Description",
    )
    id: UUID = Field(..., description="Unique id of the attribute", title="Id")
    key: Optional[str] = Field(None, description="action key", title="Key")


class AuditLogObjects(BaseModel):
    class Config:
        extra = Extra.allow

    organization_object: Optional[Union[OrganizationObj, Dict[str, Any]]] = Field(
        None, title="Organization Object"
    )
    project_object: Optional[Union[ProjectObj, Dict[str, Any]]] = Field(
        None, title="Project Object"
    )
    environment_object: Optional[Union[EnvironmentObj, Dict[str, Any]]] = Field(
        None, title="Environment Object"
    )
    pdp_config_object: Optional[Union[PdpConfigObj, Dict[str, Any]]] = Field(
        None, title="Pdp Config Object"
    )
    user_object: Optional[UserObj] = None
    action_object: Optional[ActionObj] = None
    resource_type_object: Optional[ResourceTypeObj] = None
    tenant_object: Optional[TenantObj] = None


class AuthnMeAPIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["api_key"]] = Field("api_key", title="Actor Type")
    id: UUID = Field(..., title="Id")
    object_type: MemberAccessObj
    owner_type: APIKeyOwnerType
    org_id: UUID = Field(..., title="Org Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_id: Optional[UUID] = Field(None, title="Env Id")


class AuthnMeMemberRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["member"]] = Field("member", title="Actor Type")
    id: UUID = Field(..., title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="Given name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Family name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_onboarding: bool = Field(..., title="Is Onboarding")
    onboarding_step: OnboardingStep


class AuthnMeRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor: Union[AuthnMeMemberRead, AuthnMeUserRead, AuthnMeAPIKeyRead] = Field(
        ..., discriminator="actor_type", title="Actor"
    )


class ConditionSetCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$", min_length=1) = Field(
        ...,
        description="A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.",
        title="Key",
    )
    type: Optional[ConditionSetType] = Field(
        "userset", description="the type of the set: UserSet or ResourceSet"
    )
    autogenerated: Optional[bool] = Field(
        False,
        description="whether the set was autogenerated by the system.",
        title="Autogenerated",
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description="For ResourceSets, the id of the base resource.",
        title="Resource Id",
    )
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class ConditionSetData(BaseModel):
    class Config:
        extra = Extra.allow

    type: ConditionSetType
    key: str = Field(..., title="Key")


class DataEntryReport(BaseModel):
    class Config:
        extra = Extra.allow

    entry: DataSourceEntry = Field(
        ..., description="The entry that was processed", title="Entry"
    )
    fetched: Optional[bool] = Field(False, title="Fetched")
    saved: Optional[bool] = Field(False, title="Saved")
    hash: Optional[str] = Field(None, title="Hash")


class DataUpdateReport(BaseModel):
    class Config:
        extra = Extra.allow

    update_id: Optional[str] = Field(None, title="Update Id")
    reports: List[DataEntryReport] = Field(..., title="Reports")
    policy_hash: Optional[str] = Field(None, title="Policy Hash")


class DummyEngineModel(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Engine] = None
    timestamp: Optional[datetime] = Field(None, title="Timestamp")


class ElementsConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.",
        title="Key",
    )
    name: str = Field(..., description="The name of the elements_config", title="Name")
    elements_type: ElementsType = Field(
        ..., description="The type of the elements interface, e.g: user management"
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookCreate] = None


class ElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the elements_config", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the elements_config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the elements_config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the elements_config belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the elements_config was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the elements_config was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    is_active: bool = Field(..., title="Is Active")
    name: str = Field(..., description="The name of the elements_config", title="Name")
    elements_type: ElementsType = Field(
        ..., description="The type of the elements interface, e.g: user management"
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[PermissionLevelRoleRead]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookRead] = None


class ElementsConfigRuntimeRead(BaseModel):
    class Config:
        extra = Extra.allow

    config: ElementsConfigRead
    current_permission_level: ElementsPermissionLevel


class ElementsConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the elements_config", title="Name"
    )
    elements_type: Optional[ElementsType] = Field(
        None, description="The type of the elements interface, e.g: user management"
    )
    settings: Optional[Dict[str, Union[int, str, bool]]] = Field(
        None,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookUpdate] = None


class ElementsEnvTypeRead(BaseModel):
    class Config:
        extra = Extra.allow

    roles_to_levels: Dict[str, List[PermissionLevelRoleRead]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    elements_type: str = Field(
        ...,
        description="The type of the elements interface, e.g: user_management",
        title="Elements Type",
    )


class EnvironmentCopyScope(BaseModel):
    class Config:
        extra = Extra.allow

    resources: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Resources to copy",
        title="Resources",
    )
    roles: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Roles to copy",
        title="Roles",
    )
    user_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="User sets to copy",
        title="User Sets",
    )
    resource_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Resource sets to copy",
        title="Resource Sets",
    )


class EnvironmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class EnvironmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the environment", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the environment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the environment belongs to.",
        title="Project Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the environment was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the environment was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class EnvironmentUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the environment", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class FullData(BaseModel):
    class Config:
        extra = Extra.allow

    users: Dict[str, UserData] = Field(..., title="Users")
    tenants: Dict[str, TenantData] = Field(..., title="Tenants")
    roles: Dict[str, RoleData] = Field(..., title="Roles")
    condition_set_rules: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ..., title="Condition Set Rules"
    )
    relationships: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ..., title="Relationships"
    )
    resource_types: Dict[str, ResourceTypeData] = Field(..., title="Resource Types")
    condition_sets: Dict[str, ConditionSetData] = Field(..., title="Condition Sets")
    role_assignments: Dict[str, Dict[str, List[str]]] = Field(
        ..., title="Role Assignments"
    )


class HTTPValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    detail: Optional[List[ValidationError]] = Field(None, title="Detail")


class InviteCreate(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description="Unique id of the invite", title="Member Id"
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title="Email"
    )
    role: Optional[MemberAccessLevel] = Field(
        "admin", description="The role the member will be assigned with"
    )


class InviteRead(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description="Unique id of the invite", title="Member Id"
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title="Email"
    )
    role: Optional[MemberAccessLevel] = Field(
        "admin", description="The role the member will be assigned with"
    )
    id: UUID = Field(..., description="Unique id of the invite", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the invite belongs to.",
        title="Organization Id",
    )
    invite_code: UUID = Field(
        ...,
        description="The invite code that is sent to the member's email",
        title="Invite Code",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the invite was created (ISO_8601 format).",
        title="Created At",
    )
    status: InviteStatus = Field(
        ..., description="The status of the invite (pending, failed, etc)"
    )
    failed_reason: Optional[str] = Field(
        None,
        description="if failed, the reason the invitation failed",
        title="Failed Reason",
    )


class LanguageInstructions(BaseModel):
    class Config:
        extra = Extra.allow

    language: ProgrammingLanguage
    label: str = Field(..., title="Label")
    instructions: str = Field(..., title="Instructions")


class MappingRule(BaseModel):
    class Config:
        extra = Extra.allow

    url: AnyUrl = Field(
        ..., description="The URL to match against the request URL", title="Url"
    )
    http_method: Methods = Field(
        ..., description="The HTTP method to match against the request method"
    )
    resource: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="The resource to match against the request resource",
        title="Resource",
    )
    headers: Optional[Dict[str, str]] = Field(
        {},
        description="The headers to match against the request headers",
        title="Headers",
    )
    action: Optional[str] = Field(
        None,
        description="The action to match against the request action",
        title="Action",
    )
    priority: Optional[int] = Field(
        None,
        description="The priority of the mapping rule. The higher the priority, the higher the precedence",
        title="Priority",
    )


class MultiInviteResult(BaseModel):
    class Config:
        extra = Extra.allow

    success: List[InviteRead] = Field(..., title="Success")
    failed: Optional[List[FailedInvite]] = Field(
        [],
        description="invites that were not even attempted, and the reason why",
        title="Failed",
    )


class OPAEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal["OPA"]] = Field("OPA", title="Engine")
    decision_id: UUID = Field(..., title="Decision Id")
    labels: OPALabels
    timestamp: datetime = Field(..., title="Timestamp")
    path: str = Field(..., title="Path")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    metrics: OPAMetrics


class OPALClient(BaseModel):
    class Config:
        extra = Extra.allow

    DATA_TOPICS: List[str] = Field(..., title="Data Topics")
    CLIENT_TOKEN: str = Field(..., title="Client Token")
    SERVER_URL: str = Field(..., title="Server Url")
    SERVER_WS_URL: str = Field(..., title="Server Ws Url")
    SERVER_PUBSUB_URL: str = Field(..., title="Server Pubsub Url")
    DEFAULT_DATA_SOURCES_CONFIG_URL: str = Field(
        ..., title="Default Data Sources Config Url"
    )
    SCOPE_ID: Optional[str] = Field(None, title="Scope Id")
    SHOULD_REPORT_ON_DATA_UPDATES: Optional[bool] = Field(
        None, title="Should Report On Data Updates"
    )
    DEFAULT_UPDATE_CALLBACKS: Optional[OPALUpdateCallback] = None
    DEFAULT_UPDATE_CALLBACK_CONFIG: Optional[OPALHttpFetcherConfig] = None


class OrgMemberCreate(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(
        None, description="Unique id of the account member", title="Id"
    )
    email: Optional[EmailStr] = Field(
        None, description="Email of the user controlling this account", title="Email"
    )
    permissions: List[Permission] = Field(..., title="Permissions")


class OrgMemberRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="First name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Last name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_superuser: bool = Field(
        ...,
        description="Whether or not this user has special access to permit.io organizations",
        title="Is Superuser",
    )
    is_onboarding: bool = Field(
        ...,
        description="Whether or not this user is currently onboarding, needs to be replaced by a user journey object",
        title="Is Onboarding",
    )
    onboarding_step: OnboardingStep = Field(
        ..., description="the step the user is currently going through in onboarding"
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the account member was created (ISO_8601 format).",
        title="Created At",
    )
    last_login: Optional[datetime] = Field(
        None,
        description="Last date and time this user logged in (ISO_8601 format).",
        title="Last Login",
    )
    last_ip: Optional[str] = Field(
        "0.0.0.0",
        description="Last IP address from which this user logged in.",
        title="Last Ip",
    )
    logins_count: Optional[int] = Field(
        0,
        description="Total number of logins this user has performed.",
        title="Logins Count",
    )
    identities: List[IdentityRead] = Field(..., title="Identities")
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )


class OrgMemberReadWithGrants(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="First name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Last name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_superuser: bool = Field(
        ...,
        description="Whether or not this user has special access to permit.io organizations",
        title="Is Superuser",
    )
    is_onboarding: bool = Field(
        ...,
        description="Whether or not this user is currently onboarding, needs to be replaced by a user journey object",
        title="Is Onboarding",
    )
    onboarding_step: OnboardingStep = Field(
        ..., description="the step the user is currently going through in onboarding"
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the account member was created (ISO_8601 format).",
        title="Created At",
    )
    last_login: Optional[datetime] = Field(
        None,
        description="Last date and time this user logged in (ISO_8601 format).",
        title="Last Login",
    )
    last_ip: Optional[str] = Field(
        "0.0.0.0",
        description="Last IP address from which this user logged in.",
        title="Last Ip",
    )
    logins_count: Optional[int] = Field(
        0,
        description="Total number of logins this user has performed.",
        title="Logins Count",
    )
    identities: List[IdentityRead] = Field(..., title="Identities")
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )
    grants: List[Permission] = Field(..., title="Grants")


class OrgMemberRemovePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    permissions: List[Permission] = Field(..., title="Permissions")


class PaginatedResultActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ActivityLogEventRead] = Field(
        ..., description="List of Activity Log Events", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ElementsConfigRead] = Field(
        ..., description="List of Elements Configs", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RoleRead] = Field(..., description="List of Roles", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultRelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RelationRead] = Field(..., description="List of Relations", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultTenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[TenantRead] = Field(..., description="List of Tenants", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PolicyRepoCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.",
        title="Key",
    )
    url: constr(regex=r"^(.+@)*([\w\d\.]+):(.*)?.git$") = Field(..., title="Url")
    main_branch_name: Optional[str] = Field("main", title="Main Branch Name")
    credentials: SSHAuthData
    activate_when_validated: Optional[bool] = Field(
        False,
        description="if you want to change your policy repository to this repo right after it is validated",
        title="Activate When Validated",
    )


class PolicyRepoRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the policy repo", title="Id")
    status: PolicyRepoStatus
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.",
        title="Key",
    )
    url: constr(regex=r"^(.+@)*([\w\d\.]+):(.*)?.git$") = Field(..., title="Url")
    main_branch_name: Optional[str] = Field("main", title="Main Branch Name")
    credentials: SSHAuthData
    activate_when_validated: Optional[bool] = Field(
        False,
        description="if you want to change your policy repository to this repo right after it is validated",
        title="Activate When Validated",
    )


class PolicySynchronizerRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    payload: Union[
        FullRegeneration,
        OrganizationRegeneration,
        ProjectRegeneration,
        EnvironmentRegeneration,
    ] = Field(..., discriminator="scope", title="Payload")
    reason: str = Field(..., title="Reason")


class ProxyConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Any = Field(
        ...,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.",
        title="Key",
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class ProxyConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the proxy config", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the proxy config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the proxy config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the proxy config belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the proxy config was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the proxy config was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    secret: Any = Field(
        ...,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class ProxyConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Optional[Any] = Field(
        None,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    name: Optional[str] = Field(
        None,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class RemoteConfig(BaseModel):
    class Config:
        extra = Extra.allow

    opal_common: Optional[OPALCommon] = Field(
        default_factory=lambda: OPALCommon.parse_obj({"FETCHING_CALLBACK_TIMEOUT": 60}),
        title="Opal Common",
    )
    opal_client: OPALClient
    pdp: Optional[PdpValues] = Field({}, title="Pdp")
    context: PDPContext


class ResourceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Key",
    )
    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the resource", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the resource belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the resource belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the resource belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the resource was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the resource was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Optional[Dict[str, ActionBlockRead]] = Field(
        {},
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockRead]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), ResourceRoleRead]] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, etc.",
        title="Roles",
    )
    relations: Optional[Dict[str, RelationBlockRead]] = Field(
        {},
        description="\n        A relations definition block, typically contained within a resource type definition block.\n        The relations represents the ways you can interact with a protected resource.\n        ",
        title="Relations",
    )
    action_groups: Optional[Dict[str, List[str]]] = Field({}, title="Action Groups")


class ResourceReplace(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ResourceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the resource", title="Name"
    )
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Optional[Dict[str, ActionBlockEditable]] = Field(
        None,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ScopeConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[OpalCommonSchemasDataDataSourceConfig] = None
    id: UUID = Field(..., description="Unique id of the ScopeConfig", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the ScopeConfig belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the ScopeConfig belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the ScopeConfig belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the ScopeConfig was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the ScopeConfig was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ScopeConfigSet(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[OpalCommonSchemasDataDataSourceConfig] = None


class Statistics(BaseModel):
    class Config:
        extra = Extra.allow

    roles: conint(ge=0) = Field(..., title="Roles")
    users: conint(ge=0) = Field(..., title="Users")
    policies: conint(ge=0) = Field(..., title="Policies")
    resources: conint(ge=0) = Field(..., title="Resources")
    tenants: conint(ge=0) = Field(..., title="Tenants")
    has_decision_logs: bool = Field(..., title="Has Decision Logs")
    members: List[OrgMemberReadWithGrants] = Field(..., title="Members")


class UserInTenant(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description="The tenant key which the user is associated with",
        title="Tenant",
    )
    roles: List[str] = Field(
        ...,
        description="List of roles assigned to the user in that tenant",
        title="Roles",
    )
    status: UserStatus = Field(..., description="Whether the user has signed in or not")


class UserRead(BaseModel):
    class Config:
        extra = Extra.allow
        allow_population_by_field_name = True

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the user", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the user belongs to.",
        title="Organization Id",
        alias="org_id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the user belongs to.",
        title="Project Id",
        alias="proj_id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the user belongs to.",
        title="Environment Id",
        alias="env_id",
    )
    associated_tenants: Optional[List[UserInTenant]] = Field(
        [], title="Associated Tenants"
    )
    roles: Optional[List[UserRole]] = Field([], title="Roles")
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class APIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: Optional[MemberAccessObj] = "env"
    access_level: Optional[MemberAccessLevel] = "admin"
    owner_type: APIKeyOwnerType
    name: Optional[str] = Field(None, title="Name")
    id: UUID = Field(..., title="Id")
    secret: Optional[str] = Field(None, title="Secret")
    created_at: datetime = Field(..., title="Created At")
    created_by_member: Optional[OrgMemberRead] = None
    last_used_at: Optional[datetime] = Field(None, title="Last Used At")
    env: Optional[EnvironmentRead] = None
    project: Optional[ProjectRead] = None


class ConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.",
        title="Key",
    )
    type: Optional[ConditionSetType] = Field(
        "userset", description="the type of the set: UserSet or ResourceSet"
    )
    autogenerated: Optional[bool] = Field(
        False,
        description="whether the set was autogenerated by the system.",
        title="Autogenerated",
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description="For ResourceSets, the id of the base resource.",
        title="Resource Id",
    )
    id: UUID = Field(..., description="Unique id of the condition set", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the condition set belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the condition set belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the condition set belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the condition set was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the condition set was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    resource: Optional[ResourceRead] = None
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class DetailedAuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    raw_data: Union[
        OPAEngineDecisionLog, AVPEngineDecisionLog, DummyEngineModel
    ] = Field(..., title="Raw Data")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    context: Optional[Any] = Field(None, title="Context")
    action: Optional[str] = Field(None, title="Action")
    timestamp: datetime = Field(..., title="Timestamp")
    query: Optional[str] = Field(None, title="Query")
    user_key: Optional[str] = Field(None, title="User Key")
    user_email: Optional[str] = Field(None, title="User Email")
    user_name: Optional[str] = Field(None, title="User Name")
    resource_type: Optional[str] = Field(None, title="Resource Type")
    tenant: Optional[str] = Field(None, title="Tenant")
    decision: Optional[bool] = Field(None, title="Decision")
    reason: Optional[str] = Field(None, title="Reason")
    pdp_config_id: UUID = Field(..., title="Pdp Config Id")
    env_id: UUID = Field(..., title="Env Id")
    project_id: UUID = Field(..., title="Project Id")
    org_id: UUID = Field(..., title="Org Id")
    objects: AuditLogObjects


class EnvironmentCopyTarget(BaseModel):
    class Config:
        extra = Extra.allow

    existing: Optional[str] = Field(
        None,
        description="Identifier of an existing environment to copy into",
        title="Existing",
    )
    new: Optional[EnvironmentCreate] = Field(
        None,
        description="Description of the environment to create. This environment must not already exist.",
        title="New",
    )


class EnvironmentStats(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the environment", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the environment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the environment belongs to.",
        title="Project Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the environment was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the environment was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )
    pdp_configs: List[PDPConfigRead] = Field(..., title="Pdp Configs")
    stats: Statistics


class PaginatedResultAPIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIKeyRead] = Field(..., description="List of Api Keys", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ConditionSetRead] = Field(
        ..., description="List of Condition Sets", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ResourceRead] = Field(..., description="List of Resources", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultUserRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[UserRead] = Field(..., description="List of Users", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class EnvironmentCopy(BaseModel):
    class Config:
        extra = Extra.allow

    target_env: EnvironmentCopyTarget = Field(
        ...,
        description="If copying a new environment, the environment configuration. If copying to an existing environment, the environment identifier",
        title="Target Env",
    )
    conflict_strategy: Optional[ConflictStrategy] = Field(
        "fail",
        description="Action to take when detecting a conflict when copying. Only applies to copying into an existing environment",
        title="Conflict Strategy",
    )
    scope: Optional[EnvironmentCopyScope] = Field(
        default_factory=lambda: EnvironmentCopyScope.parse_obj(
            {
                "resources": {"include": [], "exclude": []},
                "roles": {"include": [], "exclude": []},
                "user_sets": {"include": [], "exclude": []},
                "resource_sets": {"include": [], "exclude": []},
            }
        ),
        description="Filters to include and exclude copied objects",
        title="Scope",
    )
