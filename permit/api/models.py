# generated by datamodel-codegen:
#   filename:  https://api.permit.io/v2/openapi.json
#   timestamp: 2023-05-31T09:43:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from ..utils.pydantic_version import PYDANTIC_VERSION

if PYDANTIC_VERSION < (2, 0):
    from pydantic import AnyUrl, BaseModel, EmailStr, Extra, Field, conint, constr
else:
    from pydantic.v1 import AnyUrl, BaseModel, EmailStr, Extra, Field, conint, constr  # type: ignore


from typing_extensions import Literal


class APIHistoryEventFullRead(BaseModel):
    class Config:
        extra = Extra.allow

    request_body: Optional[bytes] = Field(None, title="Request Body")
    response_body: Optional[bytes] = Field(None, title="Response Body")
    timestamp: datetime = Field(..., title="Timestamp")
    method: str = Field(..., title="Method")
    path: str = Field(..., title="Path")
    success: bool = Field(..., title="Success")
    status: int = Field(..., title="Status")
    request_id: Optional[UUID] = Field(None, title="Request Id")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")
    id: UUID = Field(..., title="Id")


class APIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    timestamp: datetime = Field(..., title="Timestamp")
    method: str = Field(..., title="Method")
    path: str = Field(..., title="Path")
    success: bool = Field(..., title="Success")
    status: int = Field(..., title="Status")
    request_id: Optional[UUID] = Field(None, title="Request Id")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")
    id: UUID = Field(..., title="Id")


class APIKeyOwnerType(str, Enum):
    pdp_config = "pdp_config"
    member = "member"
    elements = "elements"


class APIKeyScopeRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the api_key belongs to.",
        title="Organization Id",
    )
    project_id: Optional[UUID] = Field(
        None,
        description="Unique id of the project that the api_key belongs to.",
        title="Project Id",
    )
    environment_id: Optional[UUID] = Field(
        None,
        description="Unique id of the environment that the api_key belongs to.",
        title="Environment Id",
    )


class AVPEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal["AVP"]] = Field("AVP", title="Engine")
    timestamp: datetime = Field(..., title="Timestamp")
    tenant: str = Field(..., title="Tenant")
    process_time_ms: Optional[int] = Field(None, title="Process Time Ms")
    input: Dict[str, Any] = Field(..., title="Input")
    result: Dict[str, Any] = Field(..., title="Result")


class ActionBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="a more descriptive name for the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this action represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class ActionBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="a more descriptive name for the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this action represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    id: UUID = Field(..., description="Unique id of the action", title="Id")
    key: Optional[str] = Field(None, description="action key", title="Key")


class ActionObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class ActivityDetailsObject(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title="Id")
    key: Optional[str] = Field(None, title="Key")
    kind: Optional[Literal["object"]] = Field("object", title="Kind")
    type: str = Field(..., title="Type")


class ActivityDetailsObjectData(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title="Id")
    key: Optional[str] = Field(None, title="Key")


class AddRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to assign to the role. If a permission is already granted to the role it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permissions",
    )


class AttributeType(str, Enum):
    bool = "bool"
    number = "number"
    string = "string"
    time = "time"
    array = "array"
    json = "json"


class AuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    context: Optional[Any] = Field(None, title="Context")
    action: Optional[str] = Field(None, title="Action")
    timestamp: datetime = Field(..., title="Timestamp")
    query: Optional[str] = Field(None, title="Query")
    user_key: Optional[str] = Field(None, title="User Key")
    user_email: Optional[str] = Field(None, title="User Email")
    user_name: Optional[str] = Field(None, title="User Name")
    resource_type: Optional[str] = Field(None, title="Resource Type")
    tenant: Optional[str] = Field(None, title="Tenant")
    decision: Optional[bool] = Field(None, title="Decision")
    reason: Optional[str] = Field(None, title="Reason")
    pdp_config_id: UUID = Field(..., title="Pdp Config Id")
    env_id: UUID = Field(..., title="Env Id")
    project_id: UUID = Field(..., title="Project Id")
    org_id: UUID = Field(..., title="Org Id")


class AuditLogSortKey(str, Enum):
    None_ = "None"
    timestamp = "timestamp"


class AuthMechanism(str, Enum):
    Bearer = "Bearer"
    Basic = "Basic"
    Headers = "Headers"


class AuthnMeUserRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["user"]] = Field("user", title="Actor Type")
    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    org_id: UUID = Field(..., title="Org Id")
    project_id: UUID = Field(..., title="Project Id")
    env_id: UUID = Field(..., title="Env Id")
    tenant_id: UUID = Field(..., title="Tenant Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="Given name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Family name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_onboarding: Optional[Literal[False]] = Field(False, title="Is Onboarding")
    onboarding_step: Optional[Literal["done"]] = Field("done", title="Onboarding Step")


class BulkRoleAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_created: Optional[int] = Field(0, title="Assignments Created")


class BulkRoleUnAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_removed: Optional[int] = Field(0, title="Assignments Removed")


class ConditionSetRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description="The userset that will be given permission, i.e: all the users matching this rule will be given the specified permission",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description='The permission that will be granted to the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="The resourceset that represents the resources that are granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*",
        title="Resource Set",
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title="Is Role",
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title="Is Resource",
    )


class ConditionSetRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the condition set rule", title="Id")
    key: str = Field(
        ...,
        description="A unique id by which Permit will identify this condition set rule.",
        title="Key",
    )
    user_set: str = Field(
        ...,
        description="the userset that is currently granted permissions, i.e: all the users matching this rule are granted the permission on the resourceset",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description="a permission that is currently granted to the userset *on* the resourceset.",
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="the resourceset that represents the resources that are currently granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*",
        title="Resource Set",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the condition set rule belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the condition set rule belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the condition set rule belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the condition set rule was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the condition set rule was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ConditionSetRuleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description="The userset that will be unassigned these permission, i.e: all the users matching this rule will lose the specified permission",
        title="User Set",
    )
    permission: str = Field(
        ...,
        description='The permission that will be removed from the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title="Permission",
    )
    resource_set: str = Field(
        ...,
        description="The resourceset that represents the resources that are no longer granted for access, i.e: all the resources matching this rule can no longer be accessed by the userset, and will be revoked the specified *permission*",
        title="Resource Set",
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title="Is Role",
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title="Is Resource",
    )


class ConditionSetType(str, Enum):
    userset = "userset"
    resourceset = "resourceset"


class ConditionSetUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class DataSourceEntry(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="Url source to query for data", title="Url")
    config: Optional[Dict[str, Any]] = Field(
        {},
        description="Suggested fetcher configuration (e.g. auth or method) to fetch data with",
        title="Config",
    )
    topics: Optional[List[str]] = Field(
        [], description="topics the data applies to", title="Topics"
    )
    dst_path: Optional[str] = Field(
        "", description="OPA data api path to store the document at", title="Dst Path"
    )
    save_method: Optional[str] = Field(
        "PUT",
        description="Method used to write into OPA - PUT/PATCH",
        title="Save Method",
    )


class DataSourceEntryWithPollingInterval(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="Url source to query for data", title="Url")
    data: Optional[Union[Dict[str, Any], List]] = Field(
        None,
        description="Data payload to embed within the data update (instead of having the client fetch it from the url).",
        title="Data",
    )
    config: Optional[Dict[str, Any]] = Field(
        None,
        description="Suggested fetcher configuration (e.g. auth or method) to fetch data with",
        title="Config",
    )
    topics: Optional[List[str]] = Field(
        ["policy_data"], description="topics the data applies to", title="Topics"
    )
    dst_path: Optional[str] = Field(
        "", description="OPA data api path to store the document at", title="Dst Path"
    )
    save_method: Optional[str] = Field(
        "PUT",
        description="Method used to write into OPA - PUT/PATCH",
        title="Save Method",
    )
    periodic_update_interval: Optional[float] = Field(
        None,
        description="Polling interval to refresh data from data source",
        title="Periodic Update Interval",
    )


class DerivedRoleRule(BaseModel):
    class Config:
        extra = Extra.allow

    relation: str = Field(..., title="Relation")
    related_resource: str = Field(..., title="Related Resource")
    related_role: str = Field(..., title="Related Role")


class PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings(BaseModel):
    class Config:
        extra = Extra.allow

    no_direct_roles_on_object: Optional[bool] = Field(
        False,
        description="If true, the derived role will not take action if the resource has any direct role",
        title="No Direct Roles On Object",
    )


class DerivedRoleRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )
    when: Optional[PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.parse_obj(
            {"no_direct_roles_on_object": False}
        ),
        description="the settings of the derived role rule",
        title="When",
    )


class DerivedRoleRuleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )


class DerivedRoleRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    role_id: UUID = Field(
        ...,
        description="the role id that needs to exist on the related resource (from the relation)",
        title="Role Id",
    )
    resource_id: UUID = Field(
        ...,
        description="the resource id that needs to exist on the related role (from the relation)",
        title="Resource Id",
    )
    relation_id: UUID = Field(
        ...,
        description="the relation id that needs to exist between the resource and the related resource",
        title="Relation Id",
    )
    role: str = Field(
        ...,
        description="the role key that needs to exist on the related resource (from the relation)",
        title="Role",
    )
    on_resource: str = Field(
        ...,
        description="the resource key that needs to exist on the related role (from the relation)",
        title="On Resource",
    )
    linked_by_relation: str = Field(
        ...,
        description="the relation key that needs to exist between the resource and the related resource",
        title="Linked By Relation",
    )


class DevLogin(BaseModel):
    class Config:
        extra = Extra.allow

    username: str = Field(
        ...,
        description="an email address from which to create a DEV MODE session",
        title="Username",
    )


class ElementsEnvTypeUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    roles_to_levels: Optional[Dict[str, List[str]]] = Field(
        None,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )


class ElementsPermissionLevel(str, Enum):
    LEVEL_1 = "LEVEL_1"
    LEVEL_2 = "LEVEL_2"
    LEVEL_3 = "LEVEL_3"
    LEVEL_4 = "LEVEL_4"
    HIDDEN = "HIDDEN"
    UNCONFIGURED = "UNCONFIGURED"


class PermitBackendSchemasSchemaOpalDataDerivedRoleSettings(BaseModel):
    class Config:
        extra = Extra.allow

    superseded_by_direct_role: Optional[bool] = Field(
        False, title="Superseded By Direct Role"
    )


class DerivedRole(BaseModel):
    class Config:
        extra = Extra.allow

    conditions: Optional[str] = Field(None, title="Conditions")
    settings: PermitBackendSchemasSchemaOpalDataDerivedRoleSettings
    rules: List[DerivedRoleRule] = Field(..., title="Rules")


class DerivedRoleBlockEdit(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.parse_obj(
            {"no_direct_roles_on_object": False}
        ),
        description="the settings of the derived role",
        title="When",
    )
    users_with_role: Optional[List[DerivedRoleRuleCreate]] = Field(
        [], description="the rules of the derived role", title="Users With Role"
    )


class DerivedRoleBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.parse_obj(
            {"no_direct_roles_on_object": False}
        ),
        description="the settings of the derived role",
        title="When",
    )
    id: UUID = Field(..., description="The unique id of the derived_role", title="Id")
    users_with_role: Optional[List[DerivedRoleRuleRead]] = Field(
        [], description="the rules of the derived role", title="Users With Role"
    )


class ElementsRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        {},
        description="\n        A derived role defintion block, typically contained whithin a role definition.\n        The derived role is a role that is derived from the role definition.\n        ",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    permission_level: ElementsPermissionLevel


class ElementsType(str, Enum):
    user_management = "user_management"
    audit_log = "audit_log"
    approval_flow = "approval_flow"


class ElementsUserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9|@+\-\._]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )
    role: Optional[str] = Field(None, title="Role")


class ElementsUserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )


class ElementsUserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )


class EmbeddedLoginRequestOutput(BaseModel):
    class Config:
        extra = Extra.allow

    error: Optional[str] = Field(
        None,
        description="If the login request failed, this field will contain the error message",
        title="Error",
    )
    error_code: Optional[int] = Field(
        None,
        description="If the login request failed, this field will contain the error code",
        title="Error Code",
    )
    token: Optional[str] = Field(
        None,
        description="The auth token that lets your users login into permit elements",
        title="Token",
    )
    extra: Optional[str] = Field(
        None,
        description="Extra data that you can pass to the login request",
        title="Extra",
    )
    redirect_url: str = Field(
        ...,
        description="The full URL to which the user should be redirected in order to complete the login process",
        title="Redirect Url",
    )


class Engine(str, Enum):
    OPA = "OPA"
    AVP = "AVP"


class ConflictStrategy(str, Enum):
    fail = "fail"
    overwrite = "overwrite"


class EnvironmentCopyScopeFilters(BaseModel):
    class Config:
        extra = Extra.allow

    include: Optional[List[str]] = Field(
        [], description="Objects to include (use * as wildcard)", title="Include"
    )
    exclude: Optional[List[str]] = Field(
        [], description="Object to exclude (use * as wildcard)", title="Exclude"
    )


class EnvironmentObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class EnvironmentRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["environment"] = Field("environment", title="Scope")
    org_id: UUID = Field(..., title="Org Id")
    proj_id: UUID = Field(..., title="Proj Id")
    env_id: UUID = Field(..., title="Env Id")


class FailedInvite(BaseModel):
    class Config:
        extra = Extra.allow

    email: str = Field(..., title="Email")
    reason: str = Field(..., title="Reason")


class FullRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["full"] = Field("full", title="Scope")


class HttpMethods(Enum):
    get = "get"
    post = "post"
    put = "put"
    patch = "patch"
    head = "head"
    delete = "delete"


class IdentityRead(BaseModel):
    class Config:
        extra = Extra.allow

    user_id: str = Field(
        ...,
        description="Unique User Id of this identity in the identity provider (including the provider type)",
        title="User Id",
    )
    provider: str = Field(
        ...,
        description="The identity provider type this identity came from",
        title="Provider",
    )
    sub: str = Field(
        ...,
        description="Unique User Id of this identity in the identity provider (NOT including the provider type)",
        title="Sub",
    )
    email: EmailStr = Field(
        ..., description="Email connected to this account identity", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address connected to this account identity is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    auth0_info: Dict[str, Any] = Field(
        ...,
        description="Raw user info json coming from our identity provider and matching a specific account identity",
        title="Auth0 Info",
    )


class InviteAttemptResult(BaseModel):
    class Config:
        extra = Extra.allow

    invite_successful: Optional[bool] = Field(
        False, description="the invite code was accepted", title="Invite Successful"
    )
    invite_failed_reason: Optional[str] = Field(
        None,
        description="if the invite failed, the reason it failed",
        title="Invite Failed Reason",
    )


class InviteStatus(str, Enum):
    pending = "pending"
    accepted = "accepted"
    failed = "failed"
    canceled = "canceled"


class JwksObj(BaseModel):
    class Config:
        extra = Extra.allow

    keys: List[Dict[str, Any]] = Field(
        ..., description="The keys to match against the request headers", title="Keys"
    )


class Labels(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    version: str = Field(..., title="Version")


class LoginResult(BaseModel):
    class Config:
        extra = Extra.allow

    logged_in: bool = Field(
        ..., description="whether login was successful", title="Logged In"
    )
    expires_at: int = Field(
        ...,
        description="when will the login session expire (the unix timestamp in seconds)",
        title="Expires At",
    )
    active_org_id: Optional[UUID] = Field(
        None,
        description="the active organization on the session after the login",
        title="Active Org Id",
    )
    invite_attempt: Optional[InviteAttemptResult] = None


class MemberAccessLevel(str, Enum):
    admin = "admin"
    write = "write"
    read = "read"


class MemberAccessObj(str, Enum):
    org = "org"
    project = "project"
    env = "env"


class Methods(str, Enum):
    get = "get"
    post = "post"
    put = "put"
    patch = "patch"
    delete = "delete"
    head = "head"
    options = "options"


class OPADecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    decision_id: UUID = Field(..., title="Decision Id")
    labels: Labels
    run_id: Optional[UUID] = Field(None, title="Run Id")
    timestamp: datetime = Field(..., title="Timestamp")
    path: Optional[str] = Field(None, title="Path")
    input: Optional[Dict[str, Any]] = Field(None, title="Input")
    result: Optional[Dict[str, Any]] = Field(None, title="Result")


class OPALCommon(BaseModel):
    class Config:
        extra = Extra.allow

    FETCHING_CALLBACK_TIMEOUT: Optional[int] = Field(
        60, title="Fetching Callback Timeout"
    )


class OPALHttpFetcherConfig(BaseModel):
    class Config:
        extra = Extra.allow

    fetcher: Optional[str] = Field(
        None,
        description="indicates to OPAL client that it should use a custom FetcherProvider to fetch the data",
        title="Fetcher",
    )
    headers: Optional[Dict[str, str]] = Field(None, title="Headers")
    is_json: Optional[bool] = Field(True, title="Is Json")
    process_data: Optional[bool] = Field(True, title="Process Data")
    method: Optional[HttpMethods] = "get"
    data: Optional[Any] = Field(None, title="Data")


class OPALUpdateCallback(BaseModel):
    class Config:
        extra = Extra.allow

    callbacks: List[Union[str, List[Union[str, OPALHttpFetcherConfig]]]] = Field(
        ..., title="Callbacks"
    )


class OPALabels(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    version: str = Field(..., title="Version")


class OPAMetrics(BaseModel):
    class Config:
        extra = Extra.allow

    timer_rego_input_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Input Parse Ns"
    )
    timer_rego_query_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Query Parse Ns"
    )
    timer_rego_query_compile_ns: Optional[int] = Field(
        None, title="Timer Rego Query Compile Ns"
    )
    timer_rego_query_eval_ns: Optional[int] = Field(
        None, title="Timer Rego Query Eval Ns"
    )
    timer_rego_module_parse_ns: Optional[int] = Field(
        None, title="Timer Rego Module Parse Ns"
    )
    timer_rego_module_compile_ns: Optional[int] = Field(
        None, title="Timer Rego Module Compile Ns"
    )
    timer_server_handler_ns: Optional[int] = Field(
        None, title="Timer Server Handler Ns"
    )


class OnboardingStep(str, Enum):
    create_organization = "create_organization"
    create_project = "create_project"
    create_resource = "create_resource"
    create_actions = "create_actions"
    assign_permissions = "assign_permissions"
    assign_user_roles = "assign_user_roles"
    connect_sdk = "connect_sdk"
    done = "done"


class OrgMemberUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    settings: Optional[Dict[str, Any]] = Field(
        None,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )
    onboarding_step: Optional[OnboardingStep] = Field(
        None, description="updates the onboarding step (optional)"
    )


class OrganizationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    name: constr(regex=r"^[A-Za-z0-9\.\-\_\ ]+$") = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class OrganizationObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class OrganizationRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the organization", title="Id")
    created_at: datetime = Field(
        ...,
        description="Date and time when the organization was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the organization was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class OrganizationReadWithAPIKey(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the organization", title="Id")
    created_at: datetime = Field(
        ...,
        description="Date and time when the organization was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the organization was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    api_key_id: Optional[UUID] = Field(None, title="Api Key Id")
    api_key_secret: Optional[str] = Field(None, title="Api Key Secret")


class OrganizationRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["organization"] = Field("organization", title="Scope")
    org_id: UUID = Field(..., title="Org Id")


class OrganizationUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[constr(regex=r"^[A-Za-z0-9\.\-\_\ ]+$")] = Field(
        None,
        description="The name of the organization, usually it's your company's name.",
        title="Name",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )


class PDPConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    name: Optional[str] = Field(None, title="Name")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the pdp_config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the pdp_config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the pdp_config belongs to.",
        title="Environment Id",
    )
    client_secret: str = Field(..., title="Client Secret")


class PDPContext(BaseModel):
    class Config:
        extra = Extra.allow

    customer_id: UUID = Field(..., title="Customer Id")
    client_id: str = Field(..., title="Client Id")
    backend_tier: AnyUrl = Field(..., title="Backend Tier")
    component: Optional[str] = Field("sidecar", title="Component")


class PDPInfo(BaseModel):
    class Config:
        extra = Extra.allow

    version: Optional[str] = Field(None, title="Version")
    os_name: Optional[str] = Field(None, title="Os Name")
    os_release: Optional[str] = Field(None, title="Os Release")
    os_version: Optional[str] = Field(None, title="Os Version")
    os_platform: Optional[str] = Field(None, title="Os Platform")
    os_machine: Optional[str] = Field(None, title="Os Machine")
    python_version: Optional[str] = Field(None, title="Python Version")
    python_implementation: Optional[str] = Field(None, title="Python Implementation")


class PDPOPAInfo(BaseModel):
    class Config:
        extra = Extra.allow

    version: Optional[str] = Field(None, title="Version")
    go_version: Optional[str] = Field(None, title="Go Version")
    platform: Optional[str] = Field(None, title="Platform")
    have_webassembly: Optional[bool] = Field(None, title="Have Webassembly")


class PDPState(BaseModel):
    class Config:
        extra = Extra.allow

    api_version: int = Field(..., title="Api Version")
    pdp: Optional[PDPInfo] = None
    opa: Optional[PDPOPAInfo] = None
    current_policy_hash: Optional[str] = Field(None, title="Current Policy Hash")
    most_recent_data: Optional[float] = Field(None, title="Most Recent Data")
    seen_sdks: Optional[List[str]] = Field(None, title="Seen Sdks")


class PDPStateUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    pdp_instance_id: UUID = Field(..., title="Pdp Instance Id")
    state: PDPState


class PaginatedResultAPIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIHistoryEventRead] = Field(
        ..., description="List of Api History Events", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultAuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[AuditLog] = Field(..., description="List of Audit Logs", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultOPADecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[OPADecisionLog] = Field(
        ..., description="List of Opa Decision Logs", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PdpConfigObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    name: str = Field(..., title="Name")


class PdpValues(BaseModel):
    class Config:
        extra = Extra.allow

    BACKEND_SERVICE_URL: str = Field(..., title="Backend Service Url")
    OPA_DECISION_LOG_INGRESS_ROUTE: str = Field(
        ..., title="Opa Decision Log Ingress Route"
    )
    OPA_DECISION_LOG_INGRESS_BACKEND_TIER_URL: str = Field(
        ..., title="Opa Decision Log Ingress Backend Tier Url"
    )


class Permission(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: MemberAccessObj
    access_level: MemberAccessLevel
    organization_key: Optional[str] = Field(None, title="Organization Key")
    project_key: Optional[str] = Field(None, title="Project Key")
    environment_key: Optional[str] = Field(None, title="Environment Key")
    organization_name: Optional[str] = Field(None, title="Organization Name")
    project_name: Optional[str] = Field(None, title="Project Name")
    environment_name: Optional[str] = Field(None, title="Environment Name")


class PermissionLevelRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the elements_env", title="Id")
    key: str = Field(
        ...,
        description="A URL-friendly name of the elements_env (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_env.",
        title="Key",
    )
    name: str = Field(..., title="Name")


class PolicyRepoStatus(str, Enum):
    invalid = "invalid"
    pending = "pending"
    valid = "valid"


class ProgrammingLanguage(Enum):
    javascript = "javascript"
    python = "python"
    dotnet = "dotnet"
    golang = "golang"
    ruby = "ruby"
    java = "java"
    kong_gateway = "kong_gateway"


class ProjectCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.",
        title="Key",
    )
    urn_namespace: Optional[constr(regex=r"[a-z0-9-]{2,}")] = Field(
        None,
        description="Optional namespace for URNs. If empty, URNs will be generated from project key.",
        title="Urn Namespace",
    )
    name: str = Field(..., description="The name of the project", title="Name")
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class ProjectObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class ProjectRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.",
        title="Key",
    )
    urn_namespace: Optional[constr(regex=r"[a-z0-9-]{2,}")] = Field(
        None,
        description="Optional namespace for URNs. If empty, URNs will be generated from project key.",
        title="Urn Namespace",
    )
    id: UUID = Field(..., description="Unique id of the project", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the project belongs to.",
        title="Organization Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the project was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the project was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the project", title="Name")
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class ProjectRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    scope: Literal["project"] = Field("project", title="Scope")
    org_id: UUID = Field(..., title="Org Id")
    proj_id: UUID = Field(..., title="Proj Id")


class ProjectUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the project", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="a longer description outlining the project objectives",
        title="Description",
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description="the settings for this project", title="Settings"
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description="the id of the policy repo to use for this project",
        title="Active Policy Repo Id",
    )


class RelationBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    resource_id: UUID = Field(
        ..., description="Unique id of the relation", title="Resource Id"
    )
    resource: str = Field(..., description="The resource key", title="Resource")


class RelationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.",
        title="Key",
    )
    name: str = Field(..., description="The name of the relation", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this relation respresents in your system",
        title="Description",
    )
    subject_resource: str = Field(
        ..., description="The subject resource ID or key", title="Subject Resource"
    )


class RelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this relation respresents in your system",
        title="Description",
    )
    subject_resource: str = Field(
        ..., description="The subject resource ID or key", title="Subject Resource"
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.",
        title="Key",
    )
    name: str = Field(..., description="The name of the relation", title="Name")
    id: UUID = Field(..., description="Unique id of the relation", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the relation belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the relation belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the relation belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the relation was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the relation was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    object_resource_id: UUID = Field(
        ..., description="The object resource id", title="Object Resource Id"
    )
    object_resource: str = Field(
        ..., description="The object resource key", title="Object Resource"
    )
    subject_resource_id: UUID = Field(
        ..., description="The subject resource id", title="Subject Resource Id"
    )


class RelationshipTupleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description="the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Subject",
    )
    relation: str = Field(
        ...,
        description="the relation to assign between the subject and object",
        title="Relation",
    )
    object: str = Field(
        ...,
        description="the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Object",
    )
    tenant: Optional[str] = Field(
        None,
        description="The tenant the subject and object belong to, if the resource instances don't exist yet, the tenant is required to create them. otherwise it is ignored",
        title="Tenant",
    )


class RelationshipTupleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description="the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Subject",
    )
    relation: str = Field(
        ...,
        description="the relation to assign between the subject and object",
        title="Relation",
    )
    object: str = Field(
        ...,
        description="the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)",
        title="Object",
    )


class RelationshipTupleObj(BaseModel):
    class Config:
        extra = Extra.allow

    subject_str: str = Field(..., title="Subject Str")
    relation_str: str = Field(..., title="Relation Str")
    object_str: str = Field(..., title="Object Str")


class RelationshipTupleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the relationship tuple", title="Id")
    subject: str = Field(
        ...,
        description="resource_key:resource_instance_key of the subject",
        title="Subject",
    )
    relation: str = Field(
        ..., description="key of the assigned relation", title="Relation"
    )
    object: str = Field(
        ...,
        description="resource_key:resource_instance_key of the object",
        title="Object",
    )
    tenant: str = Field(..., description="")
    subject_id: UUID = Field(
        ..., description="Unique id of the subject", title="Subject Id"
    )
    relation_id: UUID = Field(
        ..., description="Unique id of the relation", title="Relation Id"
    )
    object_id: UUID = Field(
        ..., description="Unique id of the object", title="Object Id"
    )
    tenant_id: UUID = Field(
        ..., description="Unique id of the tenant", title="Tenant Id"
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the relationship tuple belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the relationship tuple belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the relationship tuple belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the relationship tuple was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the relationship tuple was created (ISO_8601 format).",
        title="Updated At",
    )


class RemoveRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to remove from the role. If a permission is not found it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`,i.e: the "permission name".',
        title="Permissions",
    )


class ResourceActionCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.",
        title="Key",
    )
    name: str = Field(..., description="The name of the action", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )


class ResourceActionGroupCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.",
        title="Key",
    )
    name: str = Field(..., description="The name of the action group", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")


class ResourceActionGroupRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the action group", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the action group", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the action group belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the action group belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the action group belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the action group belongs to.",
        title="Resource Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the action group was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the action group was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceActionGroupUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the action group", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action group represents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix",
        title="Attributes",
    )
    actions: Optional[List[str]] = Field([], title="Actions")


class ResourceActionRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the action", title="Name")
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the action", title="Id")
    permission_name: str = Field(
        ...,
        description="The name of the action, prefixed by the resource the action is acting upon.",
        title="Permission Name",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the action belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the action belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the action belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the action belongs to.",
        title="Resource Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the action was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the action was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceActionUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the action", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this action respresents in your system",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix",
        title="Attributes",
    )


class ResourceAttributeCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.",
        title="Key",
    )
    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )


class ResourceAttributeRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the attribute", title="Id")
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the attribute belongs to.",
        title="Resource Id",
    )
    resource_key: str = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Resource Key",
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the attribute belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the attribute belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the attribute belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the attribute was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the attribute was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    built_in: bool = Field(
        ...,
        description="Whether the attribute is built-in, and managed by the Permit system.",
        title="Built In",
    )


class ResourceAttributeUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    type: Optional[AttributeType] = Field(
        None,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this attribute respresents in your system",
        title="Description",
    )


class ResourceAttributes(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType
    key: str = Field(..., title="Key")


class ResourceInstanceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title="Key",
    )
    tenant: Optional[str] = Field(
        None,
        description="the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.",
        title="Tenant",
    )
    resource: str = Field(
        ...,
        description="the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.",
        title="Resource",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceInstanceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title="Key",
    )
    tenant: Optional[str] = Field(
        None,
        description="the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.",
        title="Tenant",
    )
    resource: str = Field(
        ...,
        description="the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.",
        title="Resource",
    )
    id: UUID = Field(..., description="Unique id of the resource instance", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the resource instance belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the resource instance belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the resource instance belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the resource instance was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the resource instance was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    resource_id: UUID = Field(
        ...,
        description="the id of the resource (type) of this resource instance.",
        title="Resource Id",
    )
    tenant_id: Optional[UUID] = Field(
        None,
        description="the id of the tenant of this resource instance.",
        title="Tenant Id",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceInstanceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty resource attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ResourceRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class ResourceRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    resource_id: UUID = Field(
        ...,
        description="Unique id of the resource that the role belongs to.",
        title="Resource Id",
    )
    resource: str = Field(
        ...,
        description="The unique resource key that the role belongs to.",
        title="Resource",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ResourceRoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class ResourceTypeData(BaseModel):
    class Config:
        extra = Extra.allow

    actions: List[str] = Field(..., title="Actions")
    derived_roles: Dict[str, DerivedRole] = Field(..., title="Derived Roles")


class ResourceTypeObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    attributes: Optional[List[ResourceAttributes]] = Field(None, title="Attributes")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class RoleAssignmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )
    user: str = Field(
        ...,
        description="the user the role will be assigned to (accepts either the user id or the user key)",
        title="User",
    )


class RoleAssignmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the role assignment", title="Id")
    user: str = Field(..., description="the user the role is assigned to", title="User")
    role: str = Field(..., description="the role that is assigned", title="Role")
    tenant: Optional[str] = Field(
        None, description="the tenant the role is associated with", title="Tenant"
    )
    resource: Optional[str] = Field(
        None,
        description="the resource type the role is associated with",
        title="Resource",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with",
        title="Resource Instance",
    )
    resource_id: Optional[UUID] = Field(
        None, description="Unique id of the resource type", title="Resource Id"
    )
    resource_instance_id: Optional[UUID] = Field(
        None,
        description="Unique id of the resource instance",
        title="Resource Instance Id",
    )
    user_id: UUID = Field(..., description="Unique id of the user", title="User Id")
    role_id: UUID = Field(..., description="Unique id of the role", title="Role Id")
    tenant_id: UUID = Field(
        ..., description="Unique id of the tenant", title="Tenant Id"
    )
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role assignment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role assignment belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role assignment belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role assignment was created (ISO_8601 format).",
        title="Created At",
    )


class RoleAssignmentRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )
    user: str = Field(
        ...,
        description="the user the role will be unassigned from (accepts either the user id or the user key)",
        title="User",
    )


class RoleBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class RoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class RoleData(BaseModel):
    class Config:
        extra = Extra.allow

    grants: Optional[Dict[str, List[str]]] = Field(None, title="Grants")


class RoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        {},
        description="\n        A derived role defintion block, typically contained whithin a role definition.\n        The derived role is a role that is derived from the role definition.\n        ",
        title="Granted To",
    )
    key: str = Field(
        ...,
        description="A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the role", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the role belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the role belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the role belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the role was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the role was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class RoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description="The name of the role", title="Name")
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what this role represents, or what permissions are granted to it.",
        title="Description",
    )
    permissions: Optional[List[str]] = Field(
        None,
        description="list of action keys that define what actions this resource role is permitted to do",
        title="Permissions",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title="Attributes",
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description="Derived role that inherit will be applied on this role",
        title="Granted To",
    )


class SSHAuthData(BaseModel):
    class Config:
        extra = Extra.allow

    auth_type: Optional[Literal["ssh"]] = Field("ssh", title="Auth Type")
    username: str = Field(..., description="SSH username", title="Username")
    public_key: Optional[str] = Field(
        None, description="SSH public key", title="Public Key"
    )
    private_key: str = Field(..., description="SSH private key", title="Private Key")


class TenantCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).",
        title="Key",
    )
    name: str = Field(
        ..., description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class TenantCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[TenantCreate] = Field(..., title="Operations")


class TenantCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Optional[Dict[str, List[str]]] = Field(
        None, title="Roleassignments"
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class TenantDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title="Idents")


class TenantDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    name: Optional[str] = Field(None, title="Name")
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class TenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the tenant", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the tenant belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the tenant belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the tenant belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the tenant was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the tenant was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    last_action_at: datetime = Field(
        ...,
        description="Date and time when the tenant was last active (ISO_8601 format). In other words, this is the last time a permission check was done on a resource belonging to this tenant.",
        title="Last Action At",
    )
    name: str = Field(
        ..., description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class TenantUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="A descriptive name for the tenant", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the tenant",
        title="Description",
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class UserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9|@+\-\._]+$") = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class UserCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title="Operations")


class UserCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Optional[Dict[str, List[str]]] = Field(
        None, title="Roleassignments"
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")


class UserDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title="Idents")


class UserDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserFELoginRequestInput(BaseModel):
    class Config:
        extra = Extra.allow

    user_jwt: str = Field(
        ...,
        description="jwt of the user for whom to generate a token, Note: the sub of this jwt must match the user key that exists in permit database",
        title="User Jwt",
    )
    tenant_id: str = Field(
        ...,
        description="ID or key of the tenant to which access is requested",
        title="Tenant Id",
    )


class UserLoginRequestInput(BaseModel):
    class Config:
        extra = Extra.allow

    user_id: str = Field(
        ...,
        description="ID or key of the user for whom to generate a token",
        title="User Id",
    )
    tenant_id: str = Field(
        ...,
        description="ID or key of the tenant to which access is requested",
        title="Tenant Id",
    )


class UserObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    key: str = Field(..., title="Key")
    email: Optional[str] = Field(None, title="Email")
    first_name: Optional[str] = Field(None, title="First Name")
    last_name: Optional[str] = Field(None, title="Last Name")
    attributes: Optional[Dict[str, Any]] = Field(None, title="Attributes")
    assigned_roles: Optional[List[str]] = Field(None, title="Assigned Roles")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class UserReplaceBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title="Operations")


class UserReplaceBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(..., description="the role that is assigned", title="Role")
    tenant: str = Field(
        ..., description="the tenant the role is associated with", title="Tenant"
    )


class UserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be assigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )


class UserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description="the role that will be unassigned (accepts either the role id or the role key)",
        title="Role",
    )
    tenant: Optional[str] = Field(
        None,
        description="the tenant the role is associated with (accepts either the tenant id or the tenant key)",
        title="Tenant",
    )
    resource_instance: Optional[str] = Field(
        None,
        description="the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)",
        title="Resource Instance",
    )


class UserStatus(str, Enum):
    active = "active"
    pending = "pending"


class UserUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class ValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class WebhookCreate(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description="The url to POST the webhook to", title="Url")
    bearer_token: Optional[str] = Field(
        None,
        description="An optional bearer token to use to authenticate the request",
        title="Bearer Token",
    )


class WebhookRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the webhook", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the webhook belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the webhook belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the webhook belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the webhook was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the webhook was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    url: str = Field(..., description="The url to POST the webhook to", title="Url")


class WebhookUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    url: Optional[str] = Field(
        None, description="The url to POST the webhook to", title="Url"
    )
    bearer_token: Optional[str] = Field(
        None,
        description="An optional bearer token to use to authenticate the request",
        title="Bearer Token",
    )


class OpalCommonSchemasDataDataSourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    entries: Optional[List[DataSourceEntryWithPollingInterval]] = Field(
        [],
        description="list of data sources and how to fetch from them",
        title="Entries",
    )


class PermitBackendOpalApiDataDataSourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    entries: List[DataSourceEntry] = Field(
        ...,
        description="list of data sources and how to fetch from them",
        title="Entries",
    )


class APIKeyCreate(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: Optional[MemberAccessObj] = "env"
    access_level: Optional[MemberAccessLevel] = "admin"
    owner_type: Optional[APIKeyOwnerType] = "member"
    name: Optional[str] = Field(None, title="Name")


class ActivityDetailsList(BaseModel):
    class Config:
        extra = Extra.allow

    kind: Optional[Literal["list"]] = Field("list", title="Kind")
    type: str = Field(..., title="Type")
    items: List[ActivityDetailsObjectData] = Field(..., title="Items")


class ActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    timestamp: datetime = Field(..., title="Timestamp")
    activity_id: Optional[str] = Field(None, title="Activity Id")
    activity_description: Optional[str] = Field(None, title="Activity Description")
    activity_details: Optional[
        Dict[str, Union[ActivityDetailsObject, ActivityDetailsList]]
    ] = Field(None, title="Activity Details")
    client_ip: str = Field(..., title="Client Ip")
    actor_type: str = Field(..., title="Actor Type")
    actor_id: UUID = Field(..., title="Actor Id")
    actor_display_name: Optional[str] = Field(None, title="Actor Display Name")
    org_id: Optional[UUID] = Field(None, title="Org Id")
    project_key: Optional[str] = Field(None, title="Project Key")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_key: Optional[str] = Field(None, title="Env Key")
    env_id: Optional[UUID] = Field(None, title="Env Id")


class AttributeBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what data this attribute will store",
        title="Description",
    )


class AttributeBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description="The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.",
    )
    description: Optional[str] = Field(
        None,
        description="optional description string explaining what data this attribute will store",
        title="Description",
    )
    id: UUID = Field(..., description="Unique id of the attribute", title="Id")
    key: Optional[str] = Field(None, description="action key", title="Key")


class AuditLogObjects(BaseModel):
    class Config:
        extra = Extra.allow

    organization_object: Optional[Union[OrganizationObj, Dict[str, Any]]] = Field(
        None, title="Organization Object"
    )
    project_object: Optional[Union[ProjectObj, Dict[str, Any]]] = Field(
        None, title="Project Object"
    )
    environment_object: Optional[Union[EnvironmentObj, Dict[str, Any]]] = Field(
        None, title="Environment Object"
    )
    pdp_config_object: Optional[Union[PdpConfigObj, Dict[str, Any]]] = Field(
        None, title="Pdp Config Object"
    )
    user_object: Optional[UserObj] = None
    action_object: Optional[ActionObj] = None
    resource_type_object: Optional[ResourceTypeObj] = None
    tenant_object: Optional[TenantObj] = None


class AuthnMeAPIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["api_key"]] = Field("api_key", title="Actor Type")
    id: UUID = Field(..., title="Id")
    object_type: MemberAccessObj
    owner_type: APIKeyOwnerType
    org_id: UUID = Field(..., title="Org Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    env_id: Optional[UUID] = Field(None, title="Env Id")


class AuthnMeMemberRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor_type: Optional[Literal["member"]] = Field("member", title="Actor Type")
    id: UUID = Field(..., title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="Given name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Family name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_onboarding: bool = Field(..., title="Is Onboarding")
    onboarding_step: OnboardingStep


class AuthnMeRead(BaseModel):
    class Config:
        extra = Extra.allow

    actor: Union[AuthnMeMemberRead, AuthnMeUserRead, AuthnMeAPIKeyRead] = Field(
        ..., discriminator="actor_type", title="Actor"
    )


class ConditionSetCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$", min_length=1) = Field(
        ...,
        description="A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.",
        title="Key",
    )
    type: Optional[ConditionSetType] = Field(
        "userset", description="the type of the set: UserSet or ResourceSet"
    )
    autogenerated: Optional[bool] = Field(
        False,
        description="whether the set was autogenerated by the system.",
        title="Autogenerated",
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description="For ResourceSets, the id of the base resource.",
        title="Resource Id",
    )
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class ConditionSetData(BaseModel):
    class Config:
        extra = Extra.allow

    type: ConditionSetType
    key: str = Field(..., title="Key")


class DataEntryReport(BaseModel):
    class Config:
        extra = Extra.allow

    entry: DataSourceEntry = Field(
        ..., description="The entry that was processed", title="Entry"
    )
    fetched: Optional[bool] = Field(False, title="Fetched")
    saved: Optional[bool] = Field(False, title="Saved")
    hash: Optional[str] = Field(None, title="Hash")


class DataUpdateReport(BaseModel):
    class Config:
        extra = Extra.allow

    update_id: Optional[str] = Field(None, title="Update Id")
    reports: List[DataEntryReport] = Field(..., title="Reports")
    policy_hash: Optional[str] = Field(None, title="Policy Hash")


class DummyEngineModel(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Engine] = None
    timestamp: Optional[datetime] = Field(None, title="Timestamp")


class ElementsConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.",
        title="Key",
    )
    name: str = Field(..., description="The name of the elements_config", title="Name")
    elements_type: ElementsType = Field(
        ..., description="The type of the elements interface, e.g: user management"
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookCreate] = None


class ElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the elements_config", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the elements_config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the elements_config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the elements_config belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the elements_config was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the elements_config was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    is_active: bool = Field(..., title="Is Active")
    name: str = Field(..., description="The name of the elements_config", title="Name")
    elements_type: ElementsType = Field(
        ..., description="The type of the elements interface, e.g: user management"
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[PermissionLevelRoleRead]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookRead] = None


class ElementsConfigRuntimeRead(BaseModel):
    class Config:
        extra = Extra.allow

    config: ElementsConfigRead
    current_permission_level: ElementsPermissionLevel


class ElementsConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the elements_config", title="Name"
    )
    elements_type: Optional[ElementsType] = Field(
        None, description="The type of the elements interface, e.g: user management"
    )
    settings: Optional[Dict[str, Union[int, str, bool]]] = Field(
        None,
        description="Obj with the options of the elements interface, e.g: primary color",
        title="Settings",
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    webhook: Optional[WebhookUpdate] = None


class ElementsEnvTypeRead(BaseModel):
    class Config:
        extra = Extra.allow

    roles_to_levels: Dict[str, List[PermissionLevelRoleRead]] = Field(
        ...,
        description="Obj with levels as keys and role ids as values",
        title="Roles To Levels",
    )
    elements_type: str = Field(
        ...,
        description="The type of the elements interface, e.g: user_management",
        title="Elements Type",
    )


class EnvironmentCopyScope(BaseModel):
    class Config:
        extra = Extra.allow

    resources: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Resources to copy",
        title="Resources",
    )
    roles: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Roles to copy",
        title="Roles",
    )
    user_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="User sets to copy",
        title="User Sets",
    )
    resource_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {"include": [], "exclude": []}
        ),
        description="Resource sets to copy",
        title="Resource Sets",
    )


class EnvironmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class EnvironmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the environment", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the environment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the environment belongs to.",
        title="Project Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the environment was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the environment was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class EnvironmentUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the environment", title="Name"
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )


class FullData(BaseModel):
    class Config:
        extra = Extra.allow

    users: Dict[str, UserData] = Field(..., title="Users")
    tenants: Dict[str, TenantData] = Field(..., title="Tenants")
    roles: Dict[str, RoleData] = Field(..., title="Roles")
    condition_set_rules: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ..., title="Condition Set Rules"
    )
    relationships: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ..., title="Relationships"
    )
    resource_types: Dict[str, ResourceTypeData] = Field(..., title="Resource Types")
    condition_sets: Dict[str, ConditionSetData] = Field(..., title="Condition Sets")
    role_assignments: Dict[str, Dict[str, List[str]]] = Field(
        ..., title="Role Assignments"
    )


class HTTPValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    detail: Optional[List[ValidationError]] = Field(None, title="Detail")


class InviteCreate(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description="Unique id of the invite", title="Member Id"
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title="Email"
    )
    role: Optional[MemberAccessLevel] = Field(
        "admin", description="The role the member will be assigned with"
    )


class InviteRead(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description="Unique id of the invite", title="Member Id"
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title="Email"
    )
    role: Optional[MemberAccessLevel] = Field(
        "admin", description="The role the member will be assigned with"
    )
    id: UUID = Field(..., description="Unique id of the invite", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the invite belongs to.",
        title="Organization Id",
    )
    invite_code: UUID = Field(
        ...,
        description="The invite code that is sent to the member's email",
        title="Invite Code",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the invite was created (ISO_8601 format).",
        title="Created At",
    )
    status: InviteStatus = Field(
        ..., description="The status of the invite (pending, failed, etc)"
    )
    failed_reason: Optional[str] = Field(
        None,
        description="if failed, the reason the invitation failed",
        title="Failed Reason",
    )


class LanguageInstructions(BaseModel):
    class Config:
        extra = Extra.allow

    language: ProgrammingLanguage
    label: str = Field(..., title="Label")
    instructions: str = Field(..., title="Instructions")


class MappingRule(BaseModel):
    class Config:
        extra = Extra.allow

    url: AnyUrl = Field(
        ..., description="The URL to match against the request URL", title="Url"
    )
    http_method: Methods = Field(
        ..., description="The HTTP method to match against the request method"
    )
    resource: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="The resource to match against the request resource",
        title="Resource",
    )
    headers: Optional[Dict[str, str]] = Field(
        {},
        description="The headers to match against the request headers",
        title="Headers",
    )
    action: Optional[str] = Field(
        None,
        description="The action to match against the request action",
        title="Action",
    )
    priority: Optional[int] = Field(
        None,
        description="The priority of the mapping rule. The higher the priority, the higher the precedence",
        title="Priority",
    )


class MultiInviteResult(BaseModel):
    class Config:
        extra = Extra.allow

    success: List[InviteRead] = Field(..., title="Success")
    failed: Optional[List[FailedInvite]] = Field(
        [],
        description="invites that were not even attempted, and the reason why",
        title="Failed",
    )


class OPAEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal["OPA"]] = Field("OPA", title="Engine")
    decision_id: UUID = Field(..., title="Decision Id")
    labels: OPALabels
    timestamp: datetime = Field(..., title="Timestamp")
    path: str = Field(..., title="Path")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    metrics: OPAMetrics


class OPALClient(BaseModel):
    class Config:
        extra = Extra.allow

    DATA_TOPICS: List[str] = Field(..., title="Data Topics")
    CLIENT_TOKEN: str = Field(..., title="Client Token")
    SERVER_URL: str = Field(..., title="Server Url")
    SERVER_WS_URL: str = Field(..., title="Server Ws Url")
    SERVER_PUBSUB_URL: str = Field(..., title="Server Pubsub Url")
    DEFAULT_DATA_SOURCES_CONFIG_URL: str = Field(
        ..., title="Default Data Sources Config Url"
    )
    SCOPE_ID: Optional[str] = Field(None, title="Scope Id")
    SHOULD_REPORT_ON_DATA_UPDATES: Optional[bool] = Field(
        None, title="Should Report On Data Updates"
    )
    DEFAULT_UPDATE_CALLBACKS: Optional[OPALUpdateCallback] = None
    DEFAULT_UPDATE_CALLBACK_CONFIG: Optional[OPALHttpFetcherConfig] = None


class OrgMemberCreate(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(
        None, description="Unique id of the account member", title="Id"
    )
    email: Optional[EmailStr] = Field(
        None, description="Email of the user controlling this account", title="Email"
    )
    permissions: List[Permission] = Field(..., title="Permissions")


class OrgMemberRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="First name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Last name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_superuser: bool = Field(
        ...,
        description="Whether or not this user has special access to permit.io organizations",
        title="Is Superuser",
    )
    is_onboarding: bool = Field(
        ...,
        description="Whether or not this user is currently onboarding, needs to be replaced by a user journey object",
        title="Is Onboarding",
    )
    onboarding_step: OnboardingStep = Field(
        ..., description="the step the user is currently going through in onboarding"
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the account member was created (ISO_8601 format).",
        title="Created At",
    )
    last_login: Optional[datetime] = Field(
        None,
        description="Last date and time this user logged in (ISO_8601 format).",
        title="Last Login",
    )
    last_ip: Optional[str] = Field(
        "0.0.0.0",
        description="Last IP address from which this user logged in.",
        title="Last Ip",
    )
    logins_count: Optional[int] = Field(
        0,
        description="Total number of logins this user has performed.",
        title="Logins Count",
    )
    identities: List[IdentityRead] = Field(..., title="Identities")
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )


class OrgMemberReadWithGrants(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    email: EmailStr = Field(
        ..., description="Email of the user controlling this account", title="Email"
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title="Email Verified",
    )
    name: Optional[str] = Field(None, description="Name of this user", title="Name")
    given_name: Optional[str] = Field(
        None, description="First name of the user", title="Given Name"
    )
    family_name: Optional[str] = Field(
        None, description="Last name of the user", title="Family Name"
    )
    picture: Optional[str] = Field(
        None,
        description="URL to picture, photo, or avatar of the user that controls this account.",
        title="Picture",
    )
    is_superuser: bool = Field(
        ...,
        description="Whether or not this user has special access to permit.io organizations",
        title="Is Superuser",
    )
    is_onboarding: bool = Field(
        ...,
        description="Whether or not this user is currently onboarding, needs to be replaced by a user journey object",
        title="Is Onboarding",
    )
    onboarding_step: OnboardingStep = Field(
        ..., description="the step the user is currently going through in onboarding"
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the account member was created (ISO_8601 format).",
        title="Created At",
    )
    last_login: Optional[datetime] = Field(
        None,
        description="Last date and time this user logged in (ISO_8601 format).",
        title="Last Login",
    )
    last_ip: Optional[str] = Field(
        "0.0.0.0",
        description="Last IP address from which this user logged in.",
        title="Last Ip",
    )
    logins_count: Optional[int] = Field(
        0,
        description="Total number of logins this user has performed.",
        title="Logins Count",
    )
    identities: List[IdentityRead] = Field(..., title="Identities")
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description="Custom permit.io dashboard settings, such as preferred theme, etc.",
        title="Settings",
    )
    grants: List[Permission] = Field(..., title="Grants")


class OrgMemberRemovePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the account member", title="Id")
    permissions: List[Permission] = Field(..., title="Permissions")


class PaginatedResultActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ActivityLogEventRead] = Field(
        ..., description="List of Activity Log Events", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ElementsConfigRead] = Field(
        ..., description="List of Elements Configs", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RoleRead] = Field(..., description="List of Roles", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultRelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RelationRead] = Field(..., description="List of Relations", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultTenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[TenantRead] = Field(..., description="List of Tenants", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PolicyRepoCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.",
        title="Key",
    )
    url: constr(regex=r"^(.+@)*([\w\d\.]+):(.*)?.git$") = Field(..., title="Url")
    main_branch_name: Optional[str] = Field("main", title="Main Branch Name")
    credentials: SSHAuthData
    activate_when_validated: Optional[bool] = Field(
        False,
        description="if you want to change your policy repository to this repo right after it is validated",
        title="Activate When Validated",
    )


class PolicyRepoRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description="Unique id of the policy repo", title="Id")
    status: PolicyRepoStatus
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.",
        title="Key",
    )
    url: constr(regex=r"^(.+@)*([\w\d\.]+):(.*)?.git$") = Field(..., title="Url")
    main_branch_name: Optional[str] = Field("main", title="Main Branch Name")
    credentials: SSHAuthData
    activate_when_validated: Optional[bool] = Field(
        False,
        description="if you want to change your policy repository to this repo right after it is validated",
        title="Activate When Validated",
    )


class PolicySynchronizerRegeneration(BaseModel):
    class Config:
        extra = Extra.allow

    payload: Union[
        FullRegeneration,
        OrganizationRegeneration,
        ProjectRegeneration,
        EnvironmentRegeneration,
    ] = Field(..., discriminator="scope", title="Payload")
    reason: str = Field(..., title="Reason")


class ProxyConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Any = Field(
        ...,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.",
        title="Key",
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class ProxyConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the proxy config", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the proxy config belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the proxy config belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the proxy config belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the proxy config was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the proxy config was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    secret: Any = Field(
        ...,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class ProxyConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Optional[Any] = Field(
        None,
        description="Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.",
        title="Secret",
    )
    name: Optional[str] = Field(
        None,
        description="The name of the proxy config, for example: 'Stripe API'",
        title="Name",
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description="Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.",
        title="Mapping Rules",
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        "Bearer",
        description="Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.",
    )


class RemoteConfig(BaseModel):
    class Config:
        extra = Extra.allow

    opal_common: Optional[OPALCommon] = Field(
        default_factory=lambda: OPALCommon.parse_obj({"FETCHING_CALLBACK_TIMEOUT": 60}),
        title="Opal Common",
    )
    opal_client: OPALClient
    pdp: Optional[PdpValues] = Field({}, title="Pdp")
    context: PDPContext


class ResourceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r"^[A-Za-z0-9\-_]+$") = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Key",
    )
    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the resource", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the resource belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the resource belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the resource belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the resource was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the resource was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Optional[Dict[str, ActionBlockRead]] = Field(
        {},
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockRead]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), ResourceRoleRead]] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, etc.",
        title="Roles",
    )
    relations: Optional[Dict[str, RelationBlockRead]] = Field(
        {},
        description="\n        A relations definition block, typically contained within a resource type definition block.\n        The relations represents the ways you can interact with a protected resource.\n        ",
        title="Relations",
    )
    action_groups: Optional[Dict[str, List[str]]] = Field({}, title="Action Groups")


class ResourceReplace(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description="The name of the resource", title="Name")
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ResourceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description="The name of the resource", title="Name"
    )
    urn: Optional[str] = Field(
        None,
        description="The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource",
        title="Urn",
    )
    description: Optional[str] = Field(
        None,
        description="An optional longer description of what this resource respresents in your system",
        title="Description",
    )
    actions: Optional[Dict[str, ActionBlockEditable]] = Field(
        None,
        description="\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ",
        title="Actions",
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description="Attributes that each resource of this type defines, and can be used in your ABAC policies.",
        title="Attributes",
    )
    roles: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), RoleBlockEditable]
    ] = Field(
        None,
        description="Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.",
        title="Roles",
    )
    relations: Optional[
        Dict[constr(regex=r"^[A-Za-z0-9\-_]+$"), constr(regex=r"^[A-Za-z0-9\-_]+$")]
    ] = Field(
        None,
        description="Relations to other resources. The key is the relation key, and the value is the related resource.",
        title="Relations",
    )


class ScopeConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[OpalCommonSchemasDataDataSourceConfig] = None
    id: UUID = Field(..., description="Unique id of the ScopeConfig", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the ScopeConfig belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the ScopeConfig belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the ScopeConfig belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the ScopeConfig was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the ScopeConfig was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )


class ScopeConfigSet(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[OpalCommonSchemasDataDataSourceConfig] = None


class Statistics(BaseModel):
    class Config:
        extra = Extra.allow

    roles: conint(ge=0) = Field(..., title="Roles")
    users: conint(ge=0) = Field(..., title="Users")
    policies: conint(ge=0) = Field(..., title="Policies")
    resources: conint(ge=0) = Field(..., title="Resources")
    tenants: conint(ge=0) = Field(..., title="Tenants")
    has_decision_logs: bool = Field(..., title="Has Decision Logs")
    members: List[OrgMemberReadWithGrants] = Field(..., title="Members")


class UserInTenant(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description="The tenant key which the user is associated with",
        title="Tenant",
    )
    roles: List[str] = Field(
        ...,
        description="List of roles assigned to the user in that tenant",
        title="Roles",
    )
    status: UserStatus = Field(..., description="Whether the user has signed in or not")


class UserRead(BaseModel):
    class Config:
        extra = Extra.allow
        allow_population_by_field_name = True

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the user for permission checks.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the user", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the user belongs to.",
        title="Organization Id",
        alias="org_id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the user belongs to.",
        title="Project Id",
        alias="proj_id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the user belongs to.",
        title="Environment Id",
        alias="env_id",
    )
    associated_tenants: Optional[List[UserInTenant]] = Field(
        [], title="Associated Tenants"
    )
    roles: Optional[List[UserRole]] = Field([], title="Roles")
    email: Optional[EmailStr] = Field(
        None,
        description="The email of the user. If synced, will be unique inside the environment.",
        title="Email",
    )
    first_name: Optional[str] = Field(
        None, description="First name of the user.", title="First Name"
    )
    last_name: Optional[str] = Field(
        None, description="Last name of the user.", title="Last Name"
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description="Arbitrary user attributes that will be used to enforce attribute-based access control policies.",
        title="Attributes",
    )


class APIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title="Organization Id")
    project_id: Optional[UUID] = Field(None, title="Project Id")
    environment_id: Optional[UUID] = Field(None, title="Environment Id")
    object_type: Optional[MemberAccessObj] = "env"
    access_level: Optional[MemberAccessLevel] = "admin"
    owner_type: APIKeyOwnerType
    name: Optional[str] = Field(None, title="Name")
    id: UUID = Field(..., title="Id")
    secret: Optional[str] = Field(None, title="Secret")
    created_at: datetime = Field(..., title="Created At")
    created_by_member: Optional[OrgMemberRead] = None
    last_used_at: Optional[datetime] = Field(None, title="Last Used At")
    env: Optional[EnvironmentRead] = None
    project: Optional[ProjectRead] = None


class ConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.",
        title="Key",
    )
    type: Optional[ConditionSetType] = Field(
        "userset", description="the type of the set: UserSet or ResourceSet"
    )
    autogenerated: Optional[bool] = Field(
        False,
        description="whether the set was autogenerated by the system.",
        title="Autogenerated",
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description="For ResourceSets, the id of the base resource.",
        title="Resource Id",
    )
    id: UUID = Field(..., description="Unique id of the condition set", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the condition set belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the condition set belongs to.",
        title="Project Id",
    )
    environment_id: UUID = Field(
        ...,
        description="Unique id of the environment that the condition set belongs to.",
        title="Environment Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the condition set was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the condition set was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    resource: Optional[ResourceRead] = None
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title="Name",
    )
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the set",
        title="Description",
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description="a boolean expression that consists of multiple conditions, with and/or logic.",
        title="Conditions",
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description="Parent Condition Set", title="Parent Id"
    )


class DetailedAuditLog(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title="Id")
    raw_data: Union[
        OPAEngineDecisionLog, AVPEngineDecisionLog, DummyEngineModel
    ] = Field(..., title="Raw Data")
    input: Optional[Any] = Field(None, title="Input")
    result: Optional[Any] = Field(None, title="Result")
    context: Optional[Any] = Field(None, title="Context")
    action: Optional[str] = Field(None, title="Action")
    timestamp: datetime = Field(..., title="Timestamp")
    query: Optional[str] = Field(None, title="Query")
    user_key: Optional[str] = Field(None, title="User Key")
    user_email: Optional[str] = Field(None, title="User Email")
    user_name: Optional[str] = Field(None, title="User Name")
    resource_type: Optional[str] = Field(None, title="Resource Type")
    tenant: Optional[str] = Field(None, title="Tenant")
    decision: Optional[bool] = Field(None, title="Decision")
    reason: Optional[str] = Field(None, title="Reason")
    pdp_config_id: UUID = Field(..., title="Pdp Config Id")
    env_id: UUID = Field(..., title="Env Id")
    project_id: UUID = Field(..., title="Project Id")
    org_id: UUID = Field(..., title="Org Id")
    objects: AuditLogObjects


class EnvironmentCopyTarget(BaseModel):
    class Config:
        extra = Extra.allow

    existing: Optional[str] = Field(
        None,
        description="Identifier of an existing environment to copy into",
        title="Existing",
    )
    new: Optional[EnvironmentCreate] = Field(
        None,
        description="Description of the environment to create. This environment must not already exist.",
        title="New",
    )


class EnvironmentStats(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.",
        title="Key",
    )
    id: UUID = Field(..., description="Unique id of the environment", title="Id")
    organization_id: UUID = Field(
        ...,
        description="Unique id of the organization that the environment belongs to.",
        title="Organization Id",
    )
    project_id: UUID = Field(
        ...,
        description="Unique id of the project that the environment belongs to.",
        title="Project Id",
    )
    created_at: datetime = Field(
        ...,
        description="Date and time when the environment was created (ISO_8601 format).",
        title="Created At",
    )
    updated_at: datetime = Field(
        ...,
        description="Date and time when the environment was last updated/modified (ISO_8601 format).",
        title="Updated At",
    )
    name: str = Field(..., description="The name of the environment", title="Name")
    description: Optional[str] = Field(
        None,
        description="an optional longer description of the environment",
        title="Description",
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description="when using gitops feature, an optional branch name for the environment",
        title="Custom Branch Name",
    )
    jwks: Optional[JwksObj] = Field(
        None, description="jwks for element frontend only login", title="Jwks"
    )
    pdp_configs: List[PDPConfigRead] = Field(..., title="Pdp Configs")
    stats: Statistics


class PaginatedResultAPIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIKeyRead] = Field(..., description="List of Api Keys", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ConditionSetRead] = Field(
        ..., description="List of Condition Sets", title="Data"
    )
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ResourceRead] = Field(..., description="List of Resources", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class PaginatedResultUserRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[UserRead] = Field(..., description="List of Users", title="Data")
    total_count: conint(ge=0) = Field(..., title="Total Count")
    page_count: Optional[conint(ge=0)] = Field(0, title="Page Count")


class EnvironmentCopy(BaseModel):
    class Config:
        extra = Extra.allow

    target_env: EnvironmentCopyTarget = Field(
        ...,
        description="If copying a new environment, the environment configuration. If copying to an existing environment, the environment identifier",
        title="Target Env",
    )
    conflict_strategy: Optional[ConflictStrategy] = Field(
        "fail",
        description="Action to take when detecting a conflict when copying. Only applies to copying into an existing environment",
        title="Conflict Strategy",
    )
    scope: Optional[EnvironmentCopyScope] = Field(
        default_factory=lambda: EnvironmentCopyScope.parse_obj(
            {
                "resources": {"include": [], "exclude": []},
                "roles": {"include": [], "exclude": []},
                "user_sets": {"include": [], "exclude": []},
                "resource_sets": {"include": [], "exclude": []},
            }
        ),
        description="Filters to include and exclude copied objects",
        title="Scope",
    )
