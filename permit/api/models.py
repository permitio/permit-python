# generated by datamodel-codegen:
#   filename:  https://api.permit.io/v2/openapi.json
#   timestamp: 2024-10-13T11:45:49+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from ..utils.pydantic_version import PYDANTIC_VERSION

if PYDANTIC_VERSION < (2, 0):
    from pydantic import AnyUrl, BaseModel, EmailStr, Extra, Field, conint, constr
else:
    from pydantic.v1 import AnyUrl, BaseModel, EmailStr, Extra, Field, conint, constr  # type: ignore


class APIHistoryEventFullRead(BaseModel):
    class Config:
        extra = Extra.allow

    request_body: Optional[bytes] = Field(None, title='Request Body')
    response_body: Optional[bytes] = Field(None, title='Response Body')
    timestamp: datetime = Field(..., title='Timestamp')
    timestamp_utc: Optional[datetime] = Field(None, title='Timestamp Utc')
    method: str = Field(..., title='Method')
    path: str = Field(..., title='Path')
    success: bool = Field(..., title='Success')
    status: int = Field(..., title='Status')
    request_id: Optional[UUID] = Field(None, title='Request Id')
    client_ip: str = Field(..., title='Client Ip')
    actor_type: str = Field(..., title='Actor Type')
    actor_id: UUID = Field(..., title='Actor Id')
    actor_display_name: Optional[str] = Field(None, title='Actor Display Name')
    org_id: Optional[UUID] = Field(None, title='Org Id')
    project_key: Optional[str] = Field(None, title='Project Key')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    env_key: Optional[str] = Field(None, title='Env Key')
    env_id: Optional[UUID] = Field(None, title='Env Id')
    id: UUID = Field(..., title='Id')


class APIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    timestamp: datetime = Field(..., title='Timestamp')
    timestamp_utc: Optional[datetime] = Field(None, title='Timestamp Utc')
    method: str = Field(..., title='Method')
    path: str = Field(..., title='Path')
    success: bool = Field(..., title='Success')
    status: int = Field(..., title='Status')
    request_id: Optional[UUID] = Field(None, title='Request Id')
    client_ip: str = Field(..., title='Client Ip')
    actor_type: str = Field(..., title='Actor Type')
    actor_id: UUID = Field(..., title='Actor Id')
    actor_display_name: Optional[str] = Field(None, title='Actor Display Name')
    org_id: Optional[UUID] = Field(None, title='Org Id')
    project_key: Optional[str] = Field(None, title='Project Key')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    env_key: Optional[str] = Field(None, title='Env Key')
    env_id: Optional[UUID] = Field(None, title='Env Id')
    id: UUID = Field(..., title='Id')


class APIKeyOwnerType(str, Enum):
    pdp_config = 'pdp_config'
    member = 'member'
    elements = 'elements'


class APIKeyScopeRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the api_key belongs to.',
        title='Organization Id',
    )
    project_id: Optional[UUID] = Field(
        None,
        description='Unique id of the project that the api_key belongs to.',
        title='Project Id',
    )
    environment_id: Optional[UUID] = Field(
        None,
        description='Unique id of the environment that the api_key belongs to.',
        title='Environment Id',
    )


class AVPEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal['AVP']] = Field('AVP', title='Engine')
    timestamp: datetime = Field(..., title='Timestamp')
    tenant: str = Field(..., title='Tenant')
    process_time_ms: Optional[int] = Field(None, title='Process Time Ms')
    input: Dict[str, Any] = Field(..., title='Input')
    result: Dict[str, Any] = Field(..., title='Result')


class AccessRequestCreateDetails(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='tenant id or key that the user is requesting access to',
        title='Tenant',
    )
    resource: Optional[str] = Field(
        None,
        description='resource id or key that the user is requesting access to',
        title='Resource',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='resource instance id or key that the user is requesting access to',
        title='Resource Instance',
    )
    role: str = Field(
        ...,
        description='role id or key that the user is requesting access to',
        title='Role',
    )


class AccessRequestDetails(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='tenant id or key that the user is requesting access to',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='resource id or key that the user is requesting access to',
        title='Resource',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='resource instance id or key that the user is requesting access to',
        title='Resource Instance',
    )
    role: str = Field(
        ...,
        description='role id or key that the user is requesting access to',
        title='Role',
    )


class AccessRequestReview(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    role: Optional[str] = Field(
        None,
        description='role id or key that the user is requesting access to',
        title='Role',
    )


class AccessRequestReviewDeny(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )


class AccessRequestUserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    access_request_details: AccessRequestCreateDetails = Field(
        ...,
        description='details of the access request, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting access',
        title='Reason',
    )


class ActionBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='a more descriptive name for the action', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this action represents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title='Attributes')
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class ActionBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='a more descriptive name for the action', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this action represents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(None, title='Attributes')
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')
    id: UUID = Field(..., description='Unique id of the action', title='Id')
    key: Optional[str] = Field(None, description='action key', title='Key')


class ActionObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class ActivityDetailsObject(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title='Id')
    key: Optional[str] = Field(None, title='Key')
    kind: Optional[Literal['object']] = Field('object', title='Kind')
    type: str = Field(..., title='Type')


class ActivityDetailsObjectData(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title='Id')
    key: Optional[str] = Field(None, title='Key')


class AddRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to assign to the role. If a permission is already granted to the role it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title='Permissions',
    )


class ApproveMessage(BaseModel):
    class Config:
        extra = Extra.allow

    message: str = Field(..., title='Message')


class AttributeType(str, Enum):
    bool = 'bool'
    number = 'number'
    string = 'string'
    time = 'time'
    array = 'array'
    json = 'json'
    object = 'object'
    object_array = 'object_array'


class AuditLogSortKey(str, Enum):
    None_ = 'None'
    timestamp = 'timestamp'


class AuthMechanism(str, Enum):
    Bearer = 'Bearer'
    Basic = 'Basic'
    Headers = 'Headers'


class BillingTier(str, Enum):
    free = 'free'
    pro = 'pro'
    enterprise = 'enterprise'


class BulkRoleAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_created: Optional[int] = Field(0, title='Assignments Created')


class BulkRoleUnAssignmentReport(BaseModel):
    class Config:
        extra = Extra.allow

    assignments_removed: Optional[int] = Field(0, title='Assignments Removed')


class ConditionSetRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description='The userset that will be given permission, i.e: all the users matching this rule will be given the specified permission',
        title='User Set',
    )
    permission: str = Field(
        ...,
        description='The permission that will be granted to the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title='Permission',
    )
    resource_set: str = Field(
        ...,
        description='The resourceset that represents the resources that are granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*',
        title='Resource Set',
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title='Is Role',
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title='Is Resource',
    )


class ConditionSetRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the condition set rule', title='Id')
    key: str = Field(
        ...,
        description='A unique id by which Permit will identify this condition set rule.',
        title='Key',
    )
    user_set: str = Field(
        ...,
        description='the userset that is currently granted permissions, i.e: all the users matching this rule are granted the permission on the resourceset',
        title='User Set',
    )
    permission: str = Field(
        ...,
        description='a permission that is currently granted to the userset *on* the resourceset.',
        title='Permission',
    )
    resource_set: str = Field(
        ...,
        description='the resourceset that represents the resources that are currently granted for access, i.e: all the resources matching this rule can be accessed by the userset to perform the granted *permission*',
        title='Resource Set',
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the condition set rule belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the condition set rule belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the condition set rule belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the condition set rule was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the condition set rule was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class ConditionSetRuleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    user_set: str = Field(
        ...,
        description='The userset that will be unassigned these permission, i.e: all the users matching this rule will lose the specified permission',
        title='User Set',
    )
    permission: str = Field(
        ...,
        description='The permission that will be removed from the userset *on* the resourceset. The permission can be either a resource action id, or `{resource_key}:{action_key}`, i.e: the "permission name".',
        title='Permission',
    )
    resource_set: str = Field(
        ...,
        description='The resourceset that represents the resources that are no longer granted for access, i.e: all the resources matching this rule can no longer be accessed by the userset, and will be revoked the specified *permission*',
        title='Resource Set',
    )
    is_role: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the role's autogen user-set.",
        title='Is Role',
    )
    is_resource: Optional[bool] = Field(
        False,
        description="if True, will set the condition set rule to the resource's autogen resource-set.",
        title='Is Resource',
    )


class ConditionSetType(str, Enum):
    userset = 'userset'
    resourceset = 'resourceset'


class ConditionSetUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title='Name',
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the set',
        title='Description',
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description='a boolean expression that consists of multiple conditions, with and/or logic.',
        title='Conditions',
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description='Parent Condition Set', title='Parent Id'
    )


class ElementsPermissionLevel(str, Enum):
    LEVEL_1 = 'LEVEL_1'
    LEVEL_2 = 'LEVEL_2'
    LEVEL_3 = 'LEVEL_3'
    LEVEL_4 = 'LEVEL_4'
    HIDDEN = 'HIDDEN'
    UNCONFIGURED = 'UNCONFIGURED'


class ElementsRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the role', title='Id')
    key: str = Field(
        ...,
        description='A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.',
        title='Key',
    )
    name: str = Field(..., description='The name of the role', title='Name')
    permission_level: ElementsPermissionLevel


class ElementsType(str, Enum):
    user_management = 'user_management'
    audit_log = 'audit_log'
    approval_flow = 'approval_flow'
    operation_approval = 'operation_approval'
    approval_management = 'approval_management'


class ElementsUserInviteApprove(BaseModel):
    class Config:
        extra = Extra.allow

    email: EmailStr = Field(
        ..., description='The email of the user that being invited', title='Email'
    )
    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ..., description='The key of the elements user invite', title='Key'
    )
    attributes: Dict[str, Any] = Field(
        ..., description='The attributes of the user', title='Attributes'
    )


class ElementsUserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be assigned (accepts either the role id or the role key)',
        title='Role',
    )


class ElementsUserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be unassigned (accepts either the role id or the role key)',
        title='Role',
    )


class EmailMessageKeys(str, Enum):
    approval_flows_deny = 'approval_flows_deny'
    user_management_invite = 'user_management_invite'
    approval_flows_approve = 'approval_flows_approve'
    approval_flows_request = 'approval_flows_request'
    test_email = 'test_email'


class EmailTemplateMessage(BaseModel):
    class Config:
        extra = Extra.allow

    message_type: EmailMessageKeys = Field(
        ...,
        description="The key of the message, can be either 'approval_flows_deny', 'approval_flows_approve', 'approval_flows_request'",
    )
    message_content: str = Field(
        ..., description='The value of the message', title='Message Content'
    )


class EmailTemplateType(str, Enum):
    approval_flows = 'approval_flows'
    user_management = 'user_management'
    test_email = 'test_email'


class EmailTemplateUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    from_address: EmailStr = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    redirect_to: AnyUrl = Field(
        ...,
        description='The redirect url the user will be redirected to after clicking the link in the email',
        title='Redirect To',
    )
    url_ttl: str = Field(
        ...,
        description='The time to live of the url in the email, in seconds',
        title='Url Ttl',
    )
    subject: str = Field(
        ..., description='The subject of the email template', title='Subject'
    )
    messages: List[EmailTemplateMessage] = Field(
        ..., description='The messages of the email template', title='Messages'
    )


class Engine(str, Enum):
    OPA = 'OPA'
    AVP = 'AVP'


class EnvironmentCopyConflictStrategy(str, Enum):
    fail = 'fail'
    overwrite = 'overwrite'


class EnvironmentCopyScopeFilters(BaseModel):
    class Config:
        extra = Extra.allow

    include: Optional[List[str]] = Field(
        [], description='Objects to include (use * as wildcard)', title='Include'
    )
    exclude: Optional[List[str]] = Field(
        [], description='Object to exclude (use * as wildcard)', title='Exclude'
    )


class EnvironmentObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class ErrorCode(str, Enum):
    INVALID_INPUT = 'INVALID_INPUT'
    INVALID_JWKS_CONFIGURATION = 'INVALID_JWKS_CONFIGURATION'
    UNEXPECTED_ERROR = 'UNEXPECTED_ERROR'
    NOT_FOUND = 'NOT_FOUND'
    DUPLICATE_ENTITY = 'DUPLICATE_ENTITY'
    EMPTY_DECISION_LOGS = 'EMPTY_DECISION_LOGS'
    MISSING_REQUEST_ATTRIBUTE = 'MISSING_REQUEST_ATTRIBUTE'
    FORBIDDEN_ACCESS = 'FORBIDDEN_ACCESS'
    INVALID_PERMISSION_FORMAT = 'INVALID_PERMISSION_FORMAT'
    MISSING_PERMISSIONS = 'MISSING_PERMISSIONS'
    UNSUPPORTED_ATTRIBUTE_TYPE = 'UNSUPPORTED_ATTRIBUTE_TYPE'
    MISSING_RESOURCE_ATTRIBUTE = 'MISSING_RESOURCE_ATTRIBUTE'
    MISMATCH_ATTRIBUTES_TYPES = 'MISMATCH_ATTRIBUTES_TYPES'
    INVALID_POLICY_REPO_STATUS = 'INVALID_POLICY_REPO_STATUS'
    INVALID_SMTP_CONFIGURATION = 'INVALID_SMTP_CONFIGURATION'
    MISMATCH_RESOURCE_INSTANCES_TENANTS = 'MISMATCH_RESOURCE_INSTANCES_TENANTS'
    PAGINATION_SIZE_OVERREACHED = 'PAGINATION_SIZE_OVERREACHED'
    MISMATCH_RELATION_TYPE = 'MISMATCH_RELATION_TYPE'
    CONCURRENT_OPERATION_DISALLOWED = 'CONCURRENT_OPERATION_DISALLOWED'


class ErrorDetails(BaseModel):
    class Config:
        extra = Extra.allow

    id: str = Field(..., title='Id')
    title: str = Field(..., title='Title')
    support_link: Optional[AnyUrl] = Field(None, title='Support Link')
    error_code: ErrorCode
    message: Optional[str] = Field('', title='Message')
    additional_info: Optional[Any] = Field(None, title='Additional Info')


class FailedInvite(BaseModel):
    class Config:
        extra = Extra.allow

    email: str = Field(..., title='Email')
    reason: str = Field(..., title='Reason')


class GroupAddRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='The role key or id that will be assigned to the group.',
        title='Role',
    )
    resource: str = Field(
        ...,
        description='The resource key or id that the role belongs to.',
        title='Resource',
    )
    resource_instance: str = Field(
        ...,
        description='The resource instance key or id that the role belongs to.',
        title='Resource Instance',
    )
    tenant: str = Field(
        ...,
        description='The tenant key or id that the role belongs to.',
        title='Tenant',
    )


class GroupAssignUser(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='The tenant key or id that the user belongs to.',
        title='Tenant',
    )


class GroupAssignment(BaseModel):
    class Config:
        extra = Extra.allow

    group_instance_key: str = Field(
        ...,
        description='The key of the resource instance that the group belongs to.',
        title='Group Instance Key',
    )


class GroupCreate(BaseModel):
    class Config:
        extra = Extra.allow

    group_resource_type_key: Optional[str] = Field(
        'group',
        description='The key of the resource type that the group belongs to.',
        title='Group Resource Type Key',
    )
    group_instance_key: str = Field(
        ...,
        description='The key of the resource instance that the group belongs to.',
        title='Group Instance Key',
    )
    group_tenant: str = Field(
        ...,
        description='The tenant key or id that the group belongs to.',
        title='Group Tenant',
    )


class GroupRead(BaseModel):
    class Config:
        extra = Extra.allow

    assigned_roles: Optional[List[str]] = Field(
        None,
        description='List of roles that are assigned to this group',
        title='Assigned Roles',
    )
    users: Optional[List[UUID]] = Field(
        None,
        description='List of user ids that are assigned to this group',
        title='Users',
    )
    group_resource_type_key: Optional[str] = Field(
        'group',
        description='The key of the resource type that the group belongs to.',
        title='Group Resource Type Key',
    )
    group_instance_key: str = Field(
        ...,
        description='The key of the resource instance that the group belongs to.',
        title='Group Instance Key',
    )
    group_tenant: str = Field(
        ...,
        description='The tenant key or id that the group belongs to.',
        title='Group Tenant',
    )


class HttpMethods(Enum):
    get = 'get'
    post = 'post'
    put = 'put'
    patch = 'patch'
    head = 'head'
    delete = 'delete'


class IdentityRead(BaseModel):
    class Config:
        extra = Extra.allow

    user_id: str = Field(
        ...,
        description='Unique User Id of this identity in the identity provider (including the provider type)',
        title='User Id',
    )
    provider: str = Field(
        ...,
        description='The identity provider type this identity came from',
        title='Provider',
    )
    sub: str = Field(
        ...,
        description='Unique User Id of this identity in the identity provider (NOT including the provider type)',
        title='Sub',
    )
    email: EmailStr = Field(
        ..., description='Email connected to this account identity', title='Email'
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address connected to this account identity is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title='Email Verified',
    )
    auth0_info: Dict[str, Any] = Field(
        ...,
        description='Raw user info json coming from our identity provider and matching a specific account identity',
        title='Auth0 Info',
    )


class InviteStatus(str, Enum):
    pending = 'pending'
    accepted = 'accepted'
    failed = 'failed'
    canceled = 'canceled'


class JSONPatchAction(BaseModel):
    class Config:
        extra = Extra.allow

    op: str = Field(..., description='patch action to perform', title='Op')
    path: str = Field(..., description='target location in modified json', title='Path')
    value: Optional[Any] = Field(
        None, description='json document, the operand of the action', title='Value'
    )
    from_: Optional[str] = Field(
        None, alias='from', description='source location in json', title='From'
    )


class JwksObj(BaseModel):
    class Config:
        extra = Extra.allow

    keys: List[Dict[str, Any]] = Field(
        ..., description='The keys to match against the request headers', title='Keys'
    )


class LimitedPaginatedResultAPIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIHistoryEventRead] = Field(
        ..., description='List of Api History Events', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')
    pagination_count: conint(ge=0) = Field(..., title='Pagination Count')


class MailgunEmailConfigurationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    from_address: str = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    api_key: str = Field(
        ..., description='The api key of the mail provider', title='Api Key'
    )
    region: str = Field(
        ..., description='The region of the mail provider', title='Region'
    )
    domain: AnyUrl = Field(
        ..., description='The domain of the mail provider', title='Domain'
    )
    email_provider_type: Optional[Literal['mailgun']] = Field(
        'mailgun',
        description='The type of the email provider',
        title='Email Provider Type',
    )


class MailgunEmailConfigurationRead(BaseModel):
    class Config:
        extra = Extra.allow

    from_address: str = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    api_key: str = Field(
        ..., description='The api key of the mail provider', title='Api Key'
    )
    region: str = Field(
        ..., description='The region of the mail provider', title='Region'
    )
    domain: AnyUrl = Field(
        ..., description='The domain of the mail provider', title='Domain'
    )
    email_provider_type: Optional[Literal['mailgun']] = Field(
        'mailgun',
        description='The type of the email provider',
        title='Email Provider Type',
    )
    id: UUID = Field(
        ..., description='Unique id of the email_configuration', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the email_configuration belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the email_configuration belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the email_configuration belongs to.',
        title='Environment Id',
    )


class MemberAccessLevel(str, Enum):
    admin = 'admin'
    write = 'write'
    read = 'read'
    no_access = 'no_access'


class MemberAccessObj(str, Enum):
    org = 'org'
    project = 'project'
    env = 'env'


class Methods(str, Enum):
    get = 'get'
    post = 'post'
    put = 'put'
    patch = 'patch'
    delete = 'delete'
    head = 'head'
    options = 'options'


class MissingUserPolicy(str, Enum):
    fail = 'fail'
    ignore = 'ignore'
    create = 'create'


class MonthlyUsage(BaseModel):
    class Config:
        extra = Extra.allow

    mau: Optional[conint(ge=0)] = Field(0, title='Mau')
    tenants: Optional[conint(ge=0)] = Field(0, title='Tenants')
    monthly_tenants: Optional[List[UUID]] = Field(
        [], title='Monthly Tenants', unique_items=True
    )
    month: Optional[conint(ge=0)] = Field(0, title='Month')
    year: Optional[conint(ge=0)] = Field(0, title='Year')


class OPALCommon(BaseModel):
    class Config:
        extra = Extra.allow

    FETCHING_CALLBACK_TIMEOUT: Optional[int] = Field(
        60, title='Fetching Callback Timeout'
    )
    AUTH_PUBLIC_KEY: str = Field(..., title='Auth Public Key')


class OPALHttpFetcherConfig(BaseModel):
    class Config:
        extra = Extra.allow

    fetcher: Optional[str] = Field(
        None,
        description='indicates to OPAL client that it should use a custom FetcherProvider to fetch the data',
        title='Fetcher',
    )
    headers: Optional[Dict[str, str]] = Field(None, title='Headers')
    is_json: Optional[bool] = Field(True, title='Is Json')
    process_data: Optional[bool] = Field(True, title='Process Data')
    method: Optional[HttpMethods] = 'get'
    data: Optional[Any] = Field(None, title='Data')


class OPALUpdateCallback(BaseModel):
    class Config:
        extra = Extra.allow

    callbacks: List[Union[str, List[Union[str, OPALHttpFetcherConfig]]]] = Field(
        ..., title='Callbacks'
    )


class OPALabels(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    version: str = Field(..., title='Version')


class OPAMetrics(BaseModel):
    class Config:
        extra = Extra.allow

    timer_rego_input_parse_ns: Optional[int] = Field(
        None, title='Timer Rego Input Parse Ns'
    )
    timer_rego_query_parse_ns: Optional[int] = Field(
        None, title='Timer Rego Query Parse Ns'
    )
    timer_rego_query_compile_ns: Optional[int] = Field(
        None, title='Timer Rego Query Compile Ns'
    )
    timer_rego_query_eval_ns: Optional[int] = Field(
        None, title='Timer Rego Query Eval Ns'
    )
    timer_rego_module_parse_ns: Optional[int] = Field(
        None, title='Timer Rego Module Parse Ns'
    )
    timer_rego_module_compile_ns: Optional[int] = Field(
        None, title='Timer Rego Module Compile Ns'
    )
    timer_server_handler_ns: Optional[int] = Field(
        None, title='Timer Server Handler Ns'
    )


class OnboardingStep(str, Enum):
    create_organization = 'create_organization'
    create_project = 'create_project'
    create_resource = 'create_resource'
    create_actions = 'create_actions'
    assign_permissions = 'assign_permissions'
    assign_user_roles = 'assign_user_roles'
    connect_sdk = 'connect_sdk'
    done = 'done'


class OperationApprovalCreateDetails(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='tenant id or key that the user is requesting operation approval for',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='resource id or key that the user is requesting operation approval for',
        title='Resource',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='resource instance id or key that the user is requesting operation approval for',
        title='Resource Instance',
    )


class OperationApprovalDetails(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='tenant id or key that the user is requesting operation approval for',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='resource id or key that the user is requesting operation approval for',
        title='Resource',
    )
    resource_instance: str = Field(
        ...,
        description='resource instance id or key that the user is requesting operation approval for',
        title='Resource Instance',
    )
    element_config_id: Optional[str] = Field(
        None,
        description='element config id or key that the user is requesting operation approval from',
        title='Element Config Id',
    )


class OperationApprovalReview(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )


class OperationApprovalUserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    access_request_details: OperationApprovalCreateDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )


class OrgMemberUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    settings: Optional[Dict[str, Any]] = Field(
        None,
        description='Custom permit.io dashboard settings, such as preferred theme, etc.',
        title='Settings',
    )
    onboarding_step: Optional[OnboardingStep] = Field(
        None, description='updates the onboarding step (optional)'
    )


class OrganizationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.',
        title='Key',
    )
    name: constr(regex=r'^[A-Za-z0-9\.\-\_\ ]+$') = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title='Name',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )


class OrganizationObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class OrganizationStatistics(BaseModel):
    class Config:
        extra = Extra.allow

    projects: conint(ge=0) = Field(..., title='Projects')
    environments: conint(ge=0) = Field(..., title='Environments')
    users: conint(ge=0) = Field(..., title='Users')


class OrganizationUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[constr(regex=r'^[A-Za-z0-9\.\-\_\ ]+$')] = Field(
        None,
        description="The name of the organization, usually it's your company's name.",
        title='Name',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )


class PDPConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    name: Optional[str] = Field(None, title='Name')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the pdp_config belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the pdp_config belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the pdp_config belongs to.',
        title='Environment Id',
    )
    client_secret: str = Field(..., title='Client Secret')
    opal_server_access_token: Optional[str] = Field(
        None, title='Opal Server Access Token'
    )
    num_shards: Optional[conint(gt=1)] = Field(None, title='Num Shards')
    debug_audit_logs: Optional[bool] = Field(
        True,
        description='Whether debug audit logs are enabled or not',
        title='Debug Audit Logs',
    )
    min_pdp_version: Optional[
        constr(
            regex=r'^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'
        )
    ] = Field(
        None,
        description='The minimum image version of PDP that can connect to this config',
        title='Min Pdp Version',
    )


class PDPContext(BaseModel):
    class Config:
        extra = Extra.allow

    customer_id: UUID = Field(..., title='Customer Id')
    client_id: str = Field(..., title='Client Id')
    backend_tier: AnyUrl = Field(..., title='Backend Tier')
    component: Optional[str] = Field('sidecar', title='Component')
    org_id: UUID = Field(..., title='Org Id')
    project_id: UUID = Field(..., title='Project Id')
    env_id: UUID = Field(..., title='Env Id')


class PDPShardMigration(BaseModel):
    class Config:
        extra = Extra.allow

    num_shards: conint(gt=1) = Field(..., title='Num Shards')


class PaginatedResultAPIHistoryEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIHistoryEventRead] = Field(
        ..., description='List of Api History Events', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PdpConfigObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    name: str = Field(..., title='Name')


class PdpValues(BaseModel):
    class Config:
        extra = Extra.allow

    BACKEND_SERVICE_URL: str = Field(..., title='Backend Service Url')
    OPA_DECISION_LOG_INGRESS_ROUTE: str = Field(
        ..., title='Opa Decision Log Ingress Route'
    )
    OPA_DECISION_LOG_INGRESS_BACKEND_TIER_URL: str = Field(
        ..., title='Opa Decision Log Ingress Backend Tier Url'
    )
    CONTROL_PLANE_RELAY_JWT_TIER: str = Field(..., title='Control Plane Relay Jwt Tier')
    CONTROL_PLANE_RELAY_API: str = Field(..., title='Control Plane Relay Api')
    CONTROL_PLANE_PDP_DELTAS_API: str = Field(..., title='Control Plane Pdp Deltas Api')
    ENABLE_EXTERNAL_DATA_MANAGER: bool = Field(
        ..., title='Enable External Data Manager'
    )
    DATA_MANAGER_REMOTE_BACKUP_URL: str = Field(
        ..., title='Data Manager Remote Backup Url'
    )


class Permission(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title='Organization Id')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    environment_id: Optional[UUID] = Field(None, title='Environment Id')
    object_type: MemberAccessObj
    access_level: MemberAccessLevel
    organization_key: Optional[str] = Field(None, title='Organization Key')
    project_key: Optional[str] = Field(None, title='Project Key')
    environment_key: Optional[str] = Field(None, title='Environment Key')
    organization_name: Optional[str] = Field(None, title='Organization Name')
    project_name: Optional[str] = Field(None, title='Project Name')
    environment_name: Optional[str] = Field(None, title='Environment Name')


class PermissionLevelRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the elements_config', title='Id')
    key: str = Field(
        ...,
        description='A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.',
        title='Key',
    )
    name: str = Field(..., title='Name')
    resource_id: UUID = Field(
        ..., description='Unique id of the resource', title='Resource Id'
    )


class PolicyRepoStatus(str, Enum):
    invalid = 'invalid'
    pending = 'pending'
    valid = 'valid'


class ProjectObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class ProjectRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.',
        title='Key',
    )
    urn_namespace: Optional[constr(regex=r'[a-z0-9-]{2,}')] = Field(
        None,
        description='Optional namespace for URNs. If empty, URNs will be generated from project key.',
        title='Urn Namespace',
    )
    id: UUID = Field(..., description='Unique id of the project', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the project belongs to.',
        title='Organization Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the project was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the project was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    name: str = Field(..., description='The name of the project', title='Name')
    description: Optional[str] = Field(
        None,
        description='a longer description outlining the project objectives',
        title='Description',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description='the id of the policy repo to use for this project',
        title='Active Policy Repo Id',
    )


class ProjectUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the project', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='a longer description outlining the project objectives',
        title='Description',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description='the id of the policy repo to use for this project',
        title='Active Policy Repo Id',
    )


class RelationBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this relation represents in your system',
        title='Description',
    )
    resource_id: UUID = Field(
        ..., description='Unique id of the relation', title='Resource Id'
    )
    relation_name: Optional[str] = Field(
        None,
        description='a more descriptive name for the relation',
        title='Relation Name',
    )
    resource: str = Field(..., description='The resource key', title='Resource')


class RelationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.',
        title='Key',
    )
    name: str = Field(..., description='The name of the relation', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this relation represents in your system',
        title='Description',
    )
    subject_resource: str = Field(
        ..., description='The subject resource ID or key', title='Subject Resource'
    )


class RelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this relation represents in your system',
        title='Description',
    )
    subject_resource: str = Field(
        ..., description='The subject resource ID or key', title='Subject Resource'
    )
    key: str = Field(
        ...,
        description='A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.',
        title='Key',
    )
    name: str = Field(..., description='The name of the relation', title='Name')
    id: UUID = Field(..., description='Unique id of the relation', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the relation belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the relation belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the relation belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the relation was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the relation was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    object_resource_id: UUID = Field(
        ..., description='The object resource id', title='Object Resource Id'
    )
    object_resource: str = Field(
        ..., description='The object resource key', title='Object Resource'
    )
    subject_resource_id: UUID = Field(
        ..., description='The subject resource id', title='Subject Resource Id'
    )


class RelationshipTupleBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description='resource_key:resource_instance_key of the subject',
        title='Subject',
    )
    relation: str = Field(
        ..., description='key of the assigned relation', title='Relation'
    )
    object: str = Field(
        ...,
        description='resource_key:resource_instance_key of the object',
        title='Object',
    )


class RelationshipTupleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description='the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)',
        title='Subject',
    )
    relation: str = Field(
        ...,
        description='the relation to assign between the subject and object',
        title='Relation',
    )
    object: str = Field(
        ...,
        description='the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)',
        title='Object',
    )
    tenant: Optional[str] = Field(
        None,
        description="The tenant the subject and object belong to, if the resource instances don't exist yet, the tenant is required to create them. otherwise it is ignored",
        title='Tenant',
    )


class RelationshipTupleCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[RelationshipTupleCreate] = Field(
        ..., max_items=1000, title='Operations'
    )


class RelationshipTupleCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class RelationshipTupleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description='the resource instance assigned the new relation (accepts either the resource instance id or resource_key:resource_instance_key)',
        title='Subject',
    )
    relation: str = Field(
        ...,
        description='the relation to assign between the subject and object',
        title='Relation',
    )
    object: str = Field(
        ...,
        description='the resource instance on which the new relation is assigned (accepts either the resource instance id or resource_key:resource_instance_key)',
        title='Object',
    )


class RelationshipTupleDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[RelationshipTupleDelete] = Field(..., max_items=1000, title='Idents')


class RelationshipTupleDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class RelationshipTupleObj(BaseModel):
    class Config:
        extra = Extra.allow

    subject_str: str = Field(..., title='Subject Str')
    relation_str: str = Field(..., title='Relation Str')
    object_str: str = Field(..., title='Object Str')


class RemoveRolePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    permissions: List[str] = Field(
        ...,
        description='List of permissions to remove from the role. If a permission is not found it is skipped. Each permission can be either a resource action id, or `{resource_key}:{action_key}`,i.e: the "permission name".',
        title='Permissions',
    )


class RequestStatus(str, Enum):
    pending = 'pending'
    approved = 'approved'
    denied = 'denied'
    canceled = 'canceled'


class RequestType(str, Enum):
    access_request = 'access_request'
    operation_approval = 'operation_approval'


class ResourceActionCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.',
        title='Key',
    )
    name: str = Field(..., description='The name of the action', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action respresents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix',
        title='Attributes',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_is_built_in: Optional[bool] = Field(None, title='V1Compat Is Built In')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class ResourceActionGroupCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.',
        title='Key',
    )
    name: str = Field(..., description='The name of the action group', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action group represents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix',
        title='Attributes',
    )
    actions: Optional[List[str]] = Field([], title='Actions')


class ResourceActionGroupRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the action group', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action group represents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix',
        title='Attributes',
    )
    actions: Optional[List[str]] = Field([], title='Actions')
    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the action group (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action group.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the action group', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the action group belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the action group belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the action group belongs to.',
        title='Environment Id',
    )
    resource_id: UUID = Field(
        ...,
        description='Unique id of the resource that the action group belongs to.',
        title='Resource Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the action group was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the action group was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class ResourceActionGroupUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the action group', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action group represents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action group. This metadata can be used to filter action groups using query parameters with attr_ prefix',
        title='Attributes',
    )
    actions: Optional[List[str]] = Field([], title='Actions')


class ResourceActionRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the action', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action respresents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix',
        title='Attributes',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_is_built_in: Optional[bool] = Field(None, title='V1Compat Is Built In')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')
    key: str = Field(
        ...,
        description='A URL-friendly name of the action (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the action.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the action', title='Id')
    permission_name: str = Field(
        ...,
        description='The name of the action, prefixed by the resource the action is acting upon.',
        title='Permission Name',
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the action belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the action belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the action belongs to.',
        title='Environment Id',
    )
    resource_id: UUID = Field(
        ...,
        description='Unique id of the resource that the action belongs to.',
        title='Resource Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the action was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the action was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class ResourceActionUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the action', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this action respresents in your system',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this action. This metadata can be used to filter actions using query parameters with attr_ prefix',
        title='Attributes',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_is_built_in: Optional[bool] = Field(None, title='V1Compat Is Built In')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class ResourceAttributeCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.',
        title='Key',
    )
    type: AttributeType = Field(
        ...,
        description='The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this attribute respresents in your system',
        title='Description',
    )


class ResourceAttributeRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description='The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this attribute respresents in your system',
        title='Description',
    )
    key: str = Field(
        ...,
        description='A URL-friendly name of the attribute (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the attribute.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the attribute', title='Id')
    resource_id: UUID = Field(
        ...,
        description='Unique id of the resource that the attribute belongs to.',
        title='Resource Id',
    )
    resource_key: str = Field(
        ...,
        description='A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.',
        title='Resource Key',
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the attribute belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the attribute belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the attribute belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the attribute was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the attribute was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    built_in: bool = Field(
        ...,
        description='Whether the attribute is built-in, and managed by the Permit system.',
        title='Built In',
    )


class ResourceAttributeUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    type: Optional[AttributeType] = Field(
        None,
        description='The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this attribute respresents in your system',
        title='Description',
    )


class ResourceAttributes(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType
    key: str = Field(..., title='Key')


class ResourceInstanceAttributeData(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: Optional[str] = Field(
        None,
        description='The tenant key that this resource instance belongs to.',
        title='Tenant',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Key-Value mapping of the attributes of the resource instance.\nThe key is the attribute key and the value is the attribute value.',
        title='Attributes',
    )


class ResourceInstanceBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title='Key',
    )
    tenant: str = Field(
        ...,
        description='the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.',
        title='Resource',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary resource attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class ResourceInstanceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title='Key',
    )
    tenant: str = Field(
        ...,
        description='the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.',
        title='Resource',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary resource attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class ResourceInstanceCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[ResourceInstanceCreate] = Field(..., title='Operations')


class ResourceInstanceCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class ResourceInstanceDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title='Idents')


class ResourceInstanceDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class ResourceInstanceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description="A unique identifier by which Permit will identify the resource instance for permission checks. You will later pass this identifier to the `permit.check()` API. A key can be anything: for example the resource db id, a url slug, a UUID or anything else as long as it's unique on your end. The resource instance key must be url-friendly.",
        title='Key',
    )
    tenant: str = Field(
        ...,
        description='the *key* of the tenant that this resource belongs to, used to enforce tenant boundaries in multi-tenant apps.',
        title='Tenant',
    )
    resource: str = Field(
        ...,
        description='the *key* of the resource (type) of this resource instance. For example: if this resource instance is the annual budget document, the key of the resource might be `document`.',
        title='Resource',
    )
    id: UUID = Field(..., description='Unique id of the resource instance', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the resource instance belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the resource instance belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the resource instance belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the resource instance was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the resource instance was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    resource_id: UUID = Field(
        ...,
        description='the id of the resource (type) of this resource instance.',
        title='Resource Id',
    )
    tenant_id: UUID = Field(
        ...,
        description='the id of the tenant of this resource instance.',
        title='Tenant Id',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary resource attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )
    relationships: Optional[List[RelationshipTupleBlockRead]] = Field(
        None,
        description='The relationships of the resource instance.',
        title='Relationships',
    )


class ResourceInstanceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary resource attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class ResourceTypeObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    attributes: Optional[List[ResourceAttributes]] = Field(None, title='Attributes')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class RoleAssignmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be assigned (accepts either the role id or the role key)',
        title='Role',
    )
    tenant: Optional[str] = Field(
        None,
        description='the tenant the role is associated with (accepts either the tenant id or the tenant key)',
        title='Tenant',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)The resource instance will be implicitly created if the tenant parameter is specified and the resource instance does not exist.',
        title='Resource Instance',
    )
    user: str = Field(
        ...,
        description='the user the role will be assigned to (accepts either the user id or the user key)',
        title='User',
    )


class RoleAssignmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the role assignment', title='Id')
    user: str = Field(..., description='the user the role is assigned to', title='User')
    role: str = Field(..., description='the role that is assigned', title='Role')
    tenant: Optional[str] = Field(
        None, description='the tenant the role is associated with', title='Tenant'
    )
    resource_instance: Optional[str] = Field(
        None,
        description='the resource instance the role is associated with',
        title='Resource Instance',
    )
    resource_instance_id: Optional[UUID] = Field(
        None,
        description='Unique id of the resource instance',
        title='Resource Instance Id',
    )
    user_id: UUID = Field(..., description='Unique id of the user', title='User Id')
    role_id: UUID = Field(..., description='Unique id of the role', title='Role Id')
    tenant_id: UUID = Field(
        ..., description='Unique id of the tenant', title='Tenant Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the role assignment belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the role assignment belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the role assignment belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the role assignment was created (ISO_8601 format).',
        title='Created At',
    )


class RoleAssignmentRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be unassigned (accepts either the role id or the role key)',
        title='Role',
    )
    tenant: str = Field(
        ...,
        description='the tenant the role is associated with (accepts either the tenant id or the tenant key)',
        title='Tenant',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)',
        title='Resource Instance',
    )
    user: str = Field(
        ...,
        description='the user the role will be unassigned from (accepts either the user id or the user key)',
        title='User',
    )


class RoleAssignmentResourceInstance(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    resource: str = Field(..., title='Resource')
    attributes: Optional[Dict[str, Any]] = Field({}, title='Attributes')


class RoleAssignmentRole(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: str = Field(..., title='Name')
    permissions: Optional[List[str]] = Field(None, title='Permissions')


class RoleAssignmentTenant(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: str = Field(..., title='Name')
    attributes: Optional[Dict[str, Any]] = Field({}, title='Attributes')


class RoleAssignmentUser(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    email: Optional[str] = Field(None, title='Email')
    first_name: Optional[str] = Field(None, title='First Name')
    last_name: Optional[str] = Field(None, title='Last Name')
    attributes: Optional[Dict[str, Any]] = Field({}, title='Attributes')


class RoleCreateBulkOperationResult(BaseModel):
    class Config:
        extra = Extra.allow

    created: List[str] = Field(..., title='Created')
    updated: List[str] = Field(..., title='Updated')


class RoleData(BaseModel):
    class Config:
        extra = Extra.allow

    grants: Dict[str, List[str]] = Field(
        ...,
        description='Key-Value mapping of the resources and actions that the role can perform.\nThe key is the resource key and the value is a list of actions that the role can perform on that resource.',
        title='Grants',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Key-Value mapping of the attributes of the role.\nThe key is the attribute key and the value is the attribute value.',
        title='Attributes',
    )


class SMTPEmailConfigurationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    host: str = Field(..., description='The host of the SMTP provider', title='Host')
    from_address: EmailStr = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    port: int = Field(..., description='The port of the SMTP provider', title='Port')
    username: str = Field(
        ..., description='The username of the SMTP provider', title='Username'
    )
    password: str = Field(
        ..., description='The password of the SMTP provider', title='Password'
    )
    email_provider_type: Optional[Literal['smtp']] = Field(
        'smtp',
        description='The type of the email provider',
        title='Email Provider Type',
    )


class SMTPEmailConfigurationRead(BaseModel):
    class Config:
        extra = Extra.allow

    host: str = Field(..., description='The host of the SMTP provider', title='Host')
    from_address: EmailStr = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    port: int = Field(..., description='The port of the SMTP provider', title='Port')
    username: str = Field(
        ..., description='The username of the SMTP provider', title='Username'
    )
    password: str = Field(
        ..., description='The password of the SMTP provider', title='Password'
    )
    email_provider_type: Optional[Literal['smtp']] = Field(
        'smtp',
        description='The type of the email provider',
        title='Email Provider Type',
    )
    id: UUID = Field(
        ..., description='Unique id of the email_configuration', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the email_configuration belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the email_configuration belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the email_configuration belongs to.',
        title='Environment Id',
    )


class SSHAuthData(BaseModel):
    class Config:
        extra = Extra.allow

    auth_type: Optional[Literal['ssh']] = Field('ssh', title='Auth Type')
    username: str = Field(..., description='SSH username', title='Username')
    public_key: Optional[str] = Field(
        None, description='SSH public key', title='Public Key'
    )
    private_key: str = Field(..., description='SSH private key', title='Private Key')


class SSHAuthDataRead(BaseModel):
    class Config:
        extra = Extra.allow

    auth_type: Optional[Literal['ssh']] = Field('ssh', title='Auth Type')
    username: str = Field(..., description='SSH username', title='Username')
    public_key: Optional[str] = Field(
        None, description='SSH public key', title='Public Key'
    )
    private_key: str = Field(..., description='SSH private key', title='Private Key')


class SearchOperator(str, Enum):
    startswith = 'startswith'
    endswith = 'endswith'
    contains = 'contains'


class StrippedRelationBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the relation (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the relation.',
        title='Key',
    )
    name: str = Field(..., description='The name of the relation', title='Name')
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this relation represents in your system',
        title='Description',
    )


class TaskStatus(str, Enum):
    processing = 'processing'
    success = 'success'
    failure = 'failure'
    cancelled = 'cancelled'


class TenantBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).',
        title='Key',
    )
    name: str = Field(
        ..., description='A descriptive name for the tenant', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the tenant',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class TenantCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).',
        title='Key',
    )
    name: str = Field(
        ..., description='A descriptive name for the tenant', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the tenant',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class TenantCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[TenantCreate] = Field(..., title='Operations')


class TenantCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Optional[Dict[str, List[str]]] = Field(
        None, title='Roleassignments'
    )
    attributes: Dict[str, Any] = Field(
        ...,
        description='Key-Value mapping of the attributes of the tenant.\nThe key is the attribute key and the value is the attribute value.',
        title='Attributes',
    )


class TenantDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(..., title='Idents')


class TenantDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class TenantObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    name: Optional[str] = Field(None, title='Name')
    attributes: Optional[Dict[str, Any]] = Field(None, title='Attributes')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class TenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A unique id by which Permit will identify the tenant. The tenant key must be url-friendly (slugified).',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the tenant', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the tenant belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the tenant belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the tenant belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the tenant was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the tenant was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    last_action_at: datetime = Field(
        ...,
        description='Date and time when the tenant was last active (ISO_8601 format). In other words, this is the last time a permission check was done on a resource belonging to this tenant.',
        title='Last Action At',
    )
    name: str = Field(
        ..., description='A descriptive name for the tenant', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the tenant',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class TenantUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='A descriptive name for the tenant', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the tenant',
        title='Description',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitraty tenant attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class UsageLimits(BaseModel):
    class Config:
        extra = Extra.allow

    mau: Optional[int] = Field(
        1000,
        description='Monthly active users limit. Default for free-tier is 1000.',
        title='Mau',
    )
    tenants: Optional[int] = Field(
        20,
        description='Number of tenants limit. Default for free-tier is 20.',
        title='Tenants',
    )
    billing_tier: Optional[BillingTier] = Field(
        'free', description='Billing tier. Default is free.'
    )


class UserCreateBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserData(BaseModel):
    class Config:
        extra = Extra.allow

    roleAssignments: Dict[str, List[str]] = Field(
        ...,
        description='Key-Value mapping of the roles assigned to the user.\nThe key is the tenant key and the value is a list of role keys assigned to the user in that tenant.',
        title='Roleassignments',
    )
    attributes: Dict[str, Any] = Field(
        ...,
        description='Key-Value mapping of the attributes of the user.\nThe key is the attribute key and the value is the attribute value.',
        title='Attributes',
    )


class UserDeleteBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    idents: List[str] = Field(
        ...,
        description='List of user idents to delete. Either the unique id or the key of the users.',
        title='Idents',
    )


class UserDeleteBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserInviteStatus(str, Enum):
    pending = 'pending'
    approved = 'approved'


class UserObj(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    key: str = Field(..., title='Key')
    email: Optional[str] = Field(None, title='Email')
    first_name: Optional[str] = Field(None, title='First Name')
    last_name: Optional[str] = Field(None, title='Last Name')
    attributes: Optional[Dict[str, Any]] = Field(None, title='Attributes')
    roles: Optional[List[RelationshipTupleObj]] = Field(None, title='Roles')
    assigned_roles: Optional[List[str]] = Field(None, title='Assigned Roles')
    created_at: datetime = Field(..., title='Created At')
    updated_at: datetime = Field(..., title='Updated At')


class UserReplaceBulkOperationResult(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class UserResourceInstanceRole(BaseModel):
    class Config:
        extra = Extra.allow

    resource_instance: str = Field(
        ...,
        description='The resource instance key which the role is associated with',
        title='Resource Instance',
    )
    resource: str = Field(
        ...,
        description='The resource type which the role is associated with',
        title='Resource',
    )
    role: str = Field(
        ..., description='The role key of this resource role', title='Role'
    )


class UserRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(..., description='the role that is assigned', title='Role')
    tenant: str = Field(
        ..., description='the tenant the role is associated with', title='Tenant'
    )


class UserRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be assigned (accepts either the role id or the role key)',
        title='Role',
    )
    tenant: Optional[str] = Field(
        None,
        description='the tenant the role is associated with (accepts either the tenant id or the tenant key)',
        title='Tenant',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)The resource instance will be implicitly created if the tenant parameter is specified and the resource instance does not exist.',
        title='Resource Instance',
    )


class UserRoleRemove(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role that will be unassigned (accepts either the role id or the role key)',
        title='Role',
    )
    tenant: str = Field(
        ...,
        description='the tenant the role is associated with (accepts either the tenant id or the tenant key)',
        title='Tenant',
    )
    resource_instance: Optional[str] = Field(
        None,
        description='the resource instance the role is associated with (accepts either the resource instance id or key using this format resource_type:resource_instance)',
        title='Resource Instance',
    )


class UserStatus(str, Enum):
    active = 'active'
    pending = 'pending'


class UserUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    email: Optional[EmailStr] = Field(
        None,
        description='The email of the user. If synced, will be unique inside the environment.',
        title='Email',
    )
    first_name: Optional[str] = Field(
        None, description='First name of the user.', title='First Name'
    )
    last_name: Optional[str] = Field(
        None, description='Last name of the user.', title='Last Name'
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary user attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class ValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    loc: List[Union[str, int]] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class WebhookCreateWithElements(BaseModel):
    class Config:
        extra = Extra.allow

    type: Optional[Literal['elements']] = Field('elements', title='Type')
    url: str = Field(..., description='The url to POST the webhook to', title='Url')
    bearer_token: Optional[str] = Field(
        None,
        description='An optional bearer token to use to authenticate the request',
        title='Bearer Token',
    )


class WebhookType(str, Enum):
    elements = 'elements'
    pdp_sync_error = 'pdp_sync_error'


class WebhookUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    url: Optional[str] = Field(
        None, description='The url to POST the webhook to', title='Url'
    )
    bearer_token: Optional[str] = Field(
        None,
        description='An optional bearer token to use to authenticate the request',
        title='Bearer Token',
    )


class PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings(BaseModel):
    class Config:
        extra = Extra.allow

    no_direct_roles_on_object: Optional[bool] = Field(
        False,
        description='If true, the derived role or the specific rule will not apply if the resource has any direct role',
        title='No Direct Roles On Object',
    )


class PermitBackendSchemasSchemaOpalDataDerivationSettings(BaseModel):
    class Config:
        extra = Extra.allow

    superseded_by_direct_role: Optional[bool] = Field(
        False,
        description='If True, the derived role is superseded by a direct role.meaning role derivation is not considered if the user has a direct role.',
        title='Superseded By Direct Role',
    )


class APIKeyCreate(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title='Organization Id')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    environment_id: Optional[UUID] = Field(None, title='Environment Id')
    object_type: Optional[MemberAccessObj] = 'env'
    access_level: Optional[MemberAccessLevel] = 'admin'
    owner_type: Optional[APIKeyOwnerType] = 'member'
    name: Optional[str] = Field(None, title='Name')


class AccessRequestApproved(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: AccessRequestDetails = Field(
        ...,
        description='details of the access request, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting access',
        title='Reason',
    )
    id: UUID = Field(..., description='Unique id of the access request', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the access request belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the access request belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the access request belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the access request was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the access request was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: Optional[UUID] = Field(
        None,
        description='optional id of the user that is requesting the access',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None, description='when the access request was reviewed', title='Reviewed At'
    )
    type: Optional[RequestType] = 'access_request'
    status: RequestStatus = Field(
        ..., description='current status of the access request'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the access request',
        title='Reviewer User Id',
    )


class AccessRequestCanceled(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: AccessRequestDetails = Field(
        ...,
        description='details of the access request, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting access',
        title='Reason',
    )
    id: UUID = Field(..., description='Unique id of the access request', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the access request belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the access request belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the access request belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the access request was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the access request was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: Optional[UUID] = Field(
        None,
        description='optional id of the user that is requesting the access',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None, description='when the access request was reviewed', title='Reviewed At'
    )
    type: Optional[RequestType] = 'access_request'
    status: RequestStatus = Field(
        ..., description='current status of the access request'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the access request',
        title='Reviewer User Id',
    )


class AccessRequestDenied(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: AccessRequestDetails = Field(
        ...,
        description='details of the access request, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting access',
        title='Reason',
    )
    id: UUID = Field(..., description='Unique id of the access request', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the access request belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the access request belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the access request belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the access request was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the access request was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: Optional[UUID] = Field(
        None,
        description='optional id of the user that is requesting the access',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None, description='when the access request was reviewed', title='Reviewed At'
    )
    type: Optional[RequestType] = 'access_request'
    status: RequestStatus = Field(
        ..., description='current status of the access request'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the access request',
        title='Reviewer User Id',
    )


class AccessRequestRead(BaseModel):
    class Config:
        extra = Extra.allow

    access_request_details: AccessRequestDetails = Field(
        ...,
        description='details of the access request, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting access',
        title='Reason',
    )
    id: UUID = Field(..., description='Unique id of the access request', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the access request belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the access request belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the access request belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the access request was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the access request was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: Optional[UUID] = Field(
        None,
        description='optional id of the user that is requesting the access',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None, description='when the access request was reviewed', title='Reviewed At'
    )
    type: Optional[RequestType] = 'access_request'
    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    status: RequestStatus = Field(
        ..., description='current status of the access request'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the access request',
        title='Reviewer User Id',
    )


class ActivityDetailsList(BaseModel):
    class Config:
        extra = Extra.allow

    kind: Optional[Literal['list']] = Field('list', title='Kind')
    type: str = Field(..., title='Type')
    items: List[ActivityDetailsObjectData] = Field(..., title='Items')


class ActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    timestamp: datetime = Field(..., title='Timestamp')
    activity_id: Optional[str] = Field(None, title='Activity Id')
    activity_description: Optional[str] = Field(None, title='Activity Description')
    activity_details: Optional[
        Dict[str, Union[ActivityDetailsObject, ActivityDetailsList]]
    ] = Field(None, title='Activity Details')
    client_ip: str = Field(..., title='Client Ip')
    actor_type: str = Field(..., title='Actor Type')
    actor_id: UUID = Field(..., title='Actor Id')
    actor_display_name: Optional[str] = Field(None, title='Actor Display Name')
    org_id: Optional[UUID] = Field(None, title='Org Id')
    project_key: Optional[str] = Field(None, title='Project Key')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    env_key: Optional[str] = Field(None, title='Env Key')
    env_id: Optional[UUID] = Field(None, title='Env Id')


class AttributeBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description='The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.',
    )
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what data this attribute will store',
        title='Description',
    )


class AttributeBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: AttributeType = Field(
        ...,
        description='The type of the attribute, we currently support: `bool`, `number` (ints, floats), `time` (a timestamp), `string`, and `json`.',
    )
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what data this attribute will store',
        title='Description',
    )
    id: UUID = Field(..., description='Unique id of the attribute', title='Id')
    key: Optional[str] = Field(None, description='action key', title='Key')


class AuditLogObjectsModel(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(None, title='Id')
    organization_object: Optional[Union[OrganizationObj, Dict[str, Any]]] = Field(
        None, title='Organization Object'
    )
    project_object: Optional[Union[ProjectObj, Dict[str, Any]]] = Field(
        None, title='Project Object'
    )
    environment_object: Optional[Union[EnvironmentObj, Dict[str, Any]]] = Field(
        None, title='Environment Object'
    )
    pdp_config_object: Optional[Union[PdpConfigObj, Dict[str, Any]]] = Field(
        None, title='Pdp Config Object'
    )
    user_object: Optional[UserObj] = None
    action_object: Optional[ActionObj] = None
    resource_type_object: Optional[ResourceTypeObj] = None
    tenant_object: Optional[TenantObj] = None
    created_at: Optional[datetime] = Field(None, title='Created At')


class ConditionSetCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$', min_length=1) = Field(
        ...,
        description='A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.',
        title='Key',
    )
    type: Optional[ConditionSetType] = Field(
        'userset', description='the type of the set: UserSet or ResourceSet'
    )
    autogenerated: Optional[bool] = Field(
        False,
        description='whether the set was autogenerated by the system.',
        title='Autogenerated',
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description='For ResourceSets, the id of the base resource.',
        title='Resource Id',
    )
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title='Name',
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the set',
        title='Description',
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description='a boolean expression that consists of multiple conditions, with and/or logic.',
        title='Conditions',
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description='Parent Condition Set', title='Parent Id'
    )


class ConditionSetData(BaseModel):
    class Config:
        extra = Extra.allow

    type: ConditionSetType = Field(..., description='The type of the condition set.')
    key: str = Field(..., description='The key of the condition set.', title='Key')


class DataSourceEntryWithPollingInterval(BaseModel):
    class Config:
        extra = Extra.allow

    url: str = Field(..., description='Url source to query for data', title='Url')
    config: Optional[Dict[str, Any]] = Field(
        None,
        description='Suggested fetcher configuration (e.g. auth or method) to fetch data with',
        title='Config',
    )
    topics: Optional[List[str]] = Field(
        ['policy_data'], description='topics the data applies to', title='Topics'
    )
    dst_path: Optional[str] = Field(
        '', description='OPA data api path to store the document at', title='Dst Path'
    )
    save_method: Optional[str] = Field(
        'PUT',
        description='Method used to write into OPA - PUT/PATCH, when using the PATCH method the data field should conform to the JSON patch schema defined in RFC 6902(https://datatracker.ietf.org/doc/html/rfc6902#section-3)',
        title='Save Method',
    )
    data: Optional[Union[List[JSONPatchAction], List, Dict[str, Any]]] = Field(
        None,
        description='Data payload to embed within the data update (instead of having the client fetch it from the url).',
        title='Data',
    )
    periodic_update_interval: Optional[float] = Field(
        None,
        description='Polling interval to refresh data from data source',
        title='Periodic Update Interval',
    )


class DerivedRoleRule(BaseModel):
    class Config:
        extra = Extra.allow

    relation: str = Field(
        ...,
        description='The relation between the resource and the related resource.',
        title='Relation',
    )
    related_resource: str = Field(
        ..., description='The related resource type key.', title='Related Resource'
    )
    related_role: str = Field(
        ..., description='The related role key.', title='Related Role'
    )
    settings: PermitBackendSchemasSchemaOpalDataDerivationSettings = Field(
        ..., description='Settings for the derived role rule.', title='Settings'
    )


class DerivedRoleRuleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role key that needs to exist on the related resource (from the relation)',
        title='Role',
    )
    on_resource: str = Field(
        ...,
        description='the resource key that needs to exist on the related role (from the relation)',
        title='On Resource',
    )
    linked_by_relation: str = Field(
        ...,
        description='the relation key that needs to exist between the resource and the related resource',
        title='Linked By Relation',
    )
    when: Optional[PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings.parse_obj(
            {'no_direct_roles_on_object': False}
        ),
        description='the settings of the derived role rule',
        title='When',
    )


class DerivedRoleRuleDelete(BaseModel):
    class Config:
        extra = Extra.allow

    role: str = Field(
        ...,
        description='the role key that needs to exist on the related resource (from the relation)',
        title='Role',
    )
    on_resource: str = Field(
        ...,
        description='the resource key that needs to exist on the related role (from the relation)',
        title='On Resource',
    )
    linked_by_relation: str = Field(
        ...,
        description='the relation key that needs to exist between the resource and the related resource',
        title='Linked By Relation',
    )
    when: Optional[PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings.parse_obj(
            {'no_direct_roles_on_object': False}
        ),
        description='the settings of the derived role rule',
        title='When',
    )


class DerivedRoleRuleRead(BaseModel):
    class Config:
        extra = Extra.allow

    role_id: UUID = Field(
        ...,
        description='the role id that needs to exist on the related resource (from the relation)',
        title='Role Id',
    )
    resource_id: UUID = Field(
        ...,
        description='the resource id that needs to exist on the related role (from the relation)',
        title='Resource Id',
    )
    relation_id: UUID = Field(
        ...,
        description='the relation id that needs to exist between the resource and the related resource',
        title='Relation Id',
    )
    role: str = Field(
        ...,
        description='the role key that needs to exist on the related resource (from the relation)',
        title='Role',
    )
    on_resource: str = Field(
        ...,
        description='the resource key that needs to exist on the related role (from the relation)',
        title='On Resource',
    )
    linked_by_relation: str = Field(
        ...,
        description='the relation key that needs to exist between the resource and the related resource',
        title='Linked By Relation',
    )
    when: Optional[PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings.parse_obj(
            {'no_direct_roles_on_object': False}
        ),
        description='the settings of the derived role rule',
        title='When',
    )


class DummyEngineModel(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Engine] = None
    timestamp: Optional[datetime] = Field(None, title='Timestamp')


class ElementsConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.',
        title='Key',
    )
    name: str = Field(..., description='The name of the elements_config', title='Name')
    elements_type: ElementsType = Field(
        ..., description='The type of the elements interface, e.g: user management'
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description='Obj with the options of the elements interface, e.g: primary color',
        title='Settings',
    )
    email_notifications: Optional[bool] = Field(
        False,
        description='Whether to send email notifications to users using your Email Provider you set',
        title='Email Notifications',
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description='Obj with levels as keys and role ids as values',
        title='Roles To Levels',
    )
    webhook: Optional[WebhookCreateWithElements] = None


class ElementsConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the elements_config', title='Name'
    )
    elements_type: Optional[ElementsType] = Field(
        None, description='The type of the elements interface, e.g: user management'
    )
    settings: Optional[Dict[str, Union[int, str, bool]]] = Field(
        None,
        description='Obj with the options of the elements interface, e.g: primary color',
        title='Settings',
    )
    email_notifications: Optional[bool] = Field(
        False,
        description='Whether to send email notifications to users using your Email Provider you set',
        title='Email Notifications',
    )
    roles_to_levels: Dict[str, List[str]] = Field(
        ...,
        description='Obj with levels as keys and role ids as values',
        title='Roles To Levels',
    )
    webhook: Optional[WebhookUpdate] = None


class ElementsUserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ...,
        description='A unique id by which Permit will identify the user for permission checks.',
        title='Key',
    )
    email: Optional[EmailStr] = Field(
        None,
        description='The email of the user. If synced, will be unique inside the environment.',
        title='Email',
    )
    first_name: Optional[str] = Field(
        None, description='First name of the user.', title='First Name'
    )
    last_name: Optional[str] = Field(
        None, description='Last name of the user.', title='Last Name'
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary user attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )
    role_assignments: Optional[List[UserRoleCreate]] = Field(
        None,
        description='List of roles to assign to the user in the environment.',
        title='Role Assignments',
    )
    role: Optional[str] = Field(None, title='Role')


class ElementsUserInviteCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ..., description='The key of the user that is being invited', title='Key'
    )
    status: UserInviteStatus = Field(..., description='The status of the user invite')
    email: EmailStr = Field(
        ..., description='The email of the user that being invited', title='Email'
    )
    first_name: str = Field(
        ...,
        description='The first name of the user that is being invited',
        title='First Name',
    )
    last_name: str = Field(
        ...,
        description='The last name of the user that is being invited',
        title='Last Name',
    )
    role_id: UUID = Field(
        ..., description='The role of the user that is being invited', title='Role Id'
    )
    tenant_id: UUID = Field(
        ...,
        description='The tenant id of the user that is being invited',
        title='Tenant Id',
    )


class ElementsUserInviteRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(
        ..., description='Unique id of the elements_user_invite', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the elements_user_invite belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the elements_user_invite belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the elements_user_invite belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the elements_user_invite was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the elements_user_invite was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ..., description='The key of the user that is being invited', title='Key'
    )
    status: UserInviteStatus = Field(..., description='The status of the user invite')
    email: EmailStr = Field(
        ..., description='The email of the user that being invited', title='Email'
    )
    first_name: str = Field(
        ...,
        description='The first name of the user that is being invited',
        title='First Name',
    )
    last_name: str = Field(
        ...,
        description='The last name of the user that is being invited',
        title='Last Name',
    )
    role_id: UUID = Field(
        ..., description='The role of the user that is being invited', title='Role Id'
    )
    tenant_id: UUID = Field(
        ...,
        description='The tenant id of the user that is being invited',
        title='Tenant Id',
    )


class ElementsUserInviteUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ..., description='The key of the user that is being invited', title='Key'
    )
    status: UserInviteStatus = Field(..., description='The status of the user invite')
    email: EmailStr = Field(
        ..., description='The email of the user that being invited', title='Email'
    )
    first_name: str = Field(
        ...,
        description='The first name of the user that is being invited',
        title='First Name',
    )
    last_name: str = Field(
        ...,
        description='The last name of the user that is being invited',
        title='Last Name',
    )
    role_id: UUID = Field(
        ..., description='The role of the user that is being invited', title='Role Id'
    )
    tenant_id: UUID = Field(
        ...,
        description='The tenant id of the user that is being invited',
        title='Tenant Id',
    )


class EmailConfigurationCreate(BaseModel):
    class Config:
        extra = Extra.allow

    __root__: Union[SMTPEmailConfigurationCreate, MailgunEmailConfigurationCreate] = (
        Field(
            ..., discriminator='email_provider_type', title='EmailConfigurationCreate'
        )
    )


class EmailConfigurationRead(BaseModel):
    class Config:
        extra = Extra.allow

    __root__: Union[SMTPEmailConfigurationRead, MailgunEmailConfigurationRead] = Field(
        ..., discriminator='email_provider_type', title='EmailConfigurationRead'
    )


class EmailTemplateRead(BaseModel):
    class Config:
        extra = Extra.allow

    template_type: EmailTemplateType = Field(
        ...,
        description="The type of the email template, can be either 'approval_flows' or 'user_management'",
    )
    id: UUID = Field(..., description='Unique id of the EmailTemplate', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the EmailTemplate belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the EmailTemplate belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the EmailTemplate belongs to.',
        title='Environment Id',
    )
    from_address: EmailStr = Field(
        ...,
        description='The from address the mails will be sent from',
        title='From Address',
    )
    redirect_to: AnyUrl = Field(
        ...,
        description='The redirect url the user will be redirected to after clicking the link in the email',
        title='Redirect To',
    )
    url_ttl: str = Field(
        ...,
        description='The time to live of the url in the email, in seconds',
        title='Url Ttl',
    )
    subject: str = Field(
        ..., description='The subject of the email template', title='Subject'
    )
    messages: List[EmailTemplateMessage] = Field(
        ..., description='The messages of the email template', title='Messages'
    )


class EnvironmentCopyScope(BaseModel):
    class Config:
        extra = Extra.allow

    resources: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {'include': [], 'exclude': []}
        ),
        description='Resources to copy',
        title='Resources',
    )
    roles: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {'include': [], 'exclude': []}
        ),
        description='Roles to copy',
        title='Roles',
    )
    user_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {'include': [], 'exclude': []}
        ),
        description='User sets to copy',
        title='User Sets',
    )
    resource_sets: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {'include': [], 'exclude': []}
        ),
        description='Resource sets to copy',
        title='Resource Sets',
    )
    custom_policies: Optional[EnvironmentCopyScopeFilters] = Field(
        default_factory=lambda: EnvironmentCopyScopeFilters.parse_obj(
            {'include': [], 'exclude': []}
        ),
        description='Custom policies to copy',
        title='Custom Policies',
    )


class HTTPValidationError(BaseModel):
    class Config:
        extra = Extra.allow

    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class HistoricalUsage(BaseModel):
    class Config:
        extra = Extra.allow

    current_month: Optional[MonthlyUsage] = None
    previous_month: Optional[MonthlyUsage] = None
    two_months_ago: Optional[MonthlyUsage] = None


class InviteCreate(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description='Unique id of the invite', title='Member Id'
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title='Email'
    )
    role: Optional[MemberAccessLevel] = Field(
        'admin', description='The role the member will be assigned with'
    )


class InviteRead(BaseModel):
    class Config:
        extra = Extra.allow

    member_id: Optional[UUID] = Field(
        None, description='Unique id of the invite', title='Member Id'
    )
    email: EmailStr = Field(
        ..., description="The invited member's email address", title='Email'
    )
    role: Optional[MemberAccessLevel] = Field(
        'admin', description='The role the member will be assigned with'
    )
    id: UUID = Field(..., description='Unique id of the invite', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the invite belongs to.',
        title='Organization Id',
    )
    invite_code: UUID = Field(
        ...,
        description="The invite code that is sent to the member's email",
        title='Invite Code',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the invite was created (ISO_8601 format).',
        title='Created At',
    )
    status: InviteStatus = Field(
        ..., description='The status of the invite (pending, failed, etc)'
    )
    failed_reason: Optional[str] = Field(
        None,
        description='if failed, the reason the invitation failed',
        title='Failed Reason',
    )


class JwksConfig(BaseModel):
    class Config:
        extra = Extra.allow

    ttl: Optional[int] = Field(
        600, description='JWKS cache TTL (in seconds)', title='Ttl'
    )
    url: Optional[constr(regex=r'^https://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(/\S*)?$')] = (
        Field(None, description='...', title='Url')
    )
    jwks: Optional[JwksObj] = Field(None, description='...', title='Jwks')


class LimitedPaginatedResultActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ActivityLogEventRead] = Field(
        ..., description='List of Activity Log Events', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')
    pagination_count: conint(ge=0) = Field(..., title='Pagination Count')


class MappingRule(BaseModel):
    class Config:
        extra = Extra.allow

    url: AnyUrl = Field(
        ..., description='The URL to match against the request URL', title='Url'
    )
    http_method: Methods = Field(
        ..., description='The HTTP method to match against the request method'
    )
    resource: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='The resource to match against the request resource',
        title='Resource',
    )
    headers: Optional[Dict[str, str]] = Field(
        {},
        description='The headers to match against the request headers',
        title='Headers',
    )
    action: Optional[str] = Field(
        None,
        description='The action to match against the request action',
        title='Action',
    )
    priority: Optional[int] = Field(
        None,
        description='The priority of the mapping rule. The higher the priority, the higher the precedence',
        title='Priority',
    )


class MultiInviteResult(BaseModel):
    class Config:
        extra = Extra.allow

    success: List[InviteRead] = Field(..., title='Success')
    failed: Optional[List[FailedInvite]] = Field(
        [],
        description='invites that were not even attempted, and the reason why',
        title='Failed',
    )


class OPAEngineDecisionLog(BaseModel):
    class Config:
        extra = Extra.allow

    engine: Optional[Literal['OPA']] = Field('OPA', title='Engine')
    decision_id: UUID = Field(..., title='Decision Id')
    labels: OPALabels
    timestamp: datetime = Field(..., title='Timestamp')
    path: str = Field(..., title='Path')
    input: Optional[Any] = Field(None, title='Input')
    result: Optional[Any] = Field(None, title='Result')
    metrics: OPAMetrics


class OPALClient(BaseModel):
    class Config:
        extra = Extra.allow

    DATA_TOPICS: List[str] = Field(..., title='Data Topics')
    CLIENT_TOKEN: str = Field(..., title='Client Token')
    SERVER_URL: str = Field(..., title='Server Url')
    SERVER_WS_URL: str = Field(..., title='Server Ws Url')
    SERVER_PUBSUB_URL: str = Field(..., title='Server Pubsub Url')
    DEFAULT_DATA_SOURCES_CONFIG_URL: str = Field(
        ..., title='Default Data Sources Config Url'
    )
    SCOPE_ID: Optional[str] = Field(None, title='Scope Id')
    SHOULD_REPORT_ON_DATA_UPDATES: Optional[bool] = Field(
        None, title='Should Report On Data Updates'
    )
    DEFAULT_UPDATE_CALLBACKS: Optional[OPALUpdateCallback] = None
    DEFAULT_UPDATE_CALLBACK_CONFIG: Optional[OPALHttpFetcherConfig] = None


class OperationApprovalApproved(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: OperationApprovalDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )
    id: UUID = Field(
        ..., description='Unique id of the operation approval ', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the operation approval  belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the operation approval  belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the operation approval  belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: UUID = Field(
        ...,
        description='optional id of the user that is requesting the approval',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description='when the operation approval was reviewed',
        title='Reviewed At',
    )
    type: Optional[RequestType] = 'operation_approval'
    status: RequestStatus = Field(
        ..., description='current status of the operation approval'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the operation approval',
        title='Reviewer User Id',
    )


class OperationApprovalCanceled(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: OperationApprovalDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )
    id: UUID = Field(
        ..., description='Unique id of the operation approval ', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the operation approval  belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the operation approval  belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the operation approval  belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: UUID = Field(
        ...,
        description='optional id of the user that is requesting the approval',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description='when the operation approval was reviewed',
        title='Reviewed At',
    )
    type: Optional[RequestType] = 'operation_approval'
    status: RequestStatus = Field(
        ..., description='current status of the operation approval'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the operation approval',
        title='Reviewer User Id',
    )


class OperationApprovalDenied(BaseModel):
    class Config:
        extra = Extra.allow

    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    access_request_details: OperationApprovalDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )
    id: UUID = Field(
        ..., description='Unique id of the operation approval ', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the operation approval  belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the operation approval  belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the operation approval  belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: UUID = Field(
        ...,
        description='optional id of the user that is requesting the approval',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description='when the operation approval was reviewed',
        title='Reviewed At',
    )
    type: Optional[RequestType] = 'operation_approval'
    status: RequestStatus = Field(
        ..., description='current status of the operation approval'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the operation approval',
        title='Reviewer User Id',
    )


class OperationApprovalList(BaseModel):
    class Config:
        extra = Extra.allow

    access_request_details: OperationApprovalDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )
    id: UUID = Field(
        ..., description='Unique id of the operation approval ', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the operation approval  belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the operation approval  belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the operation approval  belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: UUID = Field(
        ...,
        description='optional id of the user that is requesting the approval',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description='when the operation approval was reviewed',
        title='Reviewed At',
    )
    type: Optional[RequestType] = 'operation_approval'
    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    status: RequestStatus = Field(
        ..., description='current status of the operation approval'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the operation approval',
        title='Reviewer User Id',
    )
    requesting_user_email: Optional[str] = Field(
        None,
        description='email of the user that is requesting the approval',
        title='Requesting User Email',
    )
    requesting_user_first_name: Optional[str] = Field(
        None,
        description='first name of the user that is requesting the approval',
        title='Requesting User First Name',
    )
    requesting_user_last_name: Optional[str] = Field(
        None,
        description='last name of the user that is requesting the approval',
        title='Requesting User Last Name',
    )
    resource_key: Optional[str] = Field(
        None,
        description='key of the resource that the user is requesting operation approval for',
        title='Resource Key',
    )
    resource_instance_key: Optional[str] = Field(
        None,
        description='key of the resource instance that the user is requesting operation approval for',
        title='Resource Instance Key',
    )


class OperationApprovalRead(BaseModel):
    class Config:
        extra = Extra.allow

    access_request_details: OperationApprovalDetails = Field(
        ...,
        description='details of the operation approval, including the resource and tenant',
        title='Access Request Details',
    )
    reason: Optional[str] = Field(
        None,
        description='Optional business justification provided by the user requesting operation approval',
        title='Reason',
    )
    id: UUID = Field(
        ..., description='Unique id of the operation approval ', title='Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the operation approval  belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the operation approval  belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the operation approval  belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the operation approval  was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    requesting_user_id: UUID = Field(
        ...,
        description='optional id of the user that is requesting the approval',
        title='Requesting User Id',
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description='when the operation approval was reviewed',
        title='Reviewed At',
    )
    type: Optional[RequestType] = 'operation_approval'
    reviewer_comment: Optional[str] = Field(
        None,
        description='comment provided by the reviewer_user_id',
        title='Reviewer Comment',
    )
    status: RequestStatus = Field(
        ..., description='current status of the operation approval'
    )
    reviewer_user_id: Optional[UUID] = Field(
        None,
        description='Optional id of the user who review the operation approval',
        title='Reviewer User Id',
    )


class OrgMemberCreate(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[UUID] = Field(
        None, description='Unique id of the account member', title='Id'
    )
    email: Optional[EmailStr] = Field(
        None, description='Email of the user controlling this account', title='Email'
    )
    permissions: List[Permission] = Field(..., title='Permissions')


class OrgMemberRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the account member', title='Id')
    email: EmailStr = Field(
        ..., description='Email of the user controlling this account', title='Email'
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title='Email Verified',
    )
    name: Optional[str] = Field(None, description='Name of this user', title='Name')
    given_name: Optional[str] = Field(
        None, description='First name of the user', title='Given Name'
    )
    family_name: Optional[str] = Field(
        None, description='Last name of the user', title='Family Name'
    )
    picture: Optional[str] = Field(
        None,
        description='URL to picture, photo, or avatar of the user that controls this account.',
        title='Picture',
    )
    is_superuser: bool = Field(
        ...,
        description='Whether or not this user has special access to permit.io organizations',
        title='Is Superuser',
    )
    is_onboarding: bool = Field(
        ...,
        description='Whether or not this user is currently onboarding, needs to be replaced by a user journey object',
        title='Is Onboarding',
    )
    onboarding_step: OnboardingStep = Field(
        ..., description='the step the user is currently going through in onboarding'
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the account member was created (ISO_8601 format).',
        title='Created At',
    )
    last_login: Optional[datetime] = Field(
        None,
        description='Last date and time this user logged in (ISO_8601 format).',
        title='Last Login',
    )
    last_ip: Optional[str] = Field(
        '0.0.0.0',
        description='Last IP address from which this user logged in.',
        title='Last Ip',
    )
    logins_count: Optional[int] = Field(
        0,
        description='Total number of logins this user has performed.',
        title='Logins Count',
    )
    identities: List[IdentityRead] = Field(..., title='Identities')
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description='Custom permit.io dashboard settings, such as preferred theme, etc.',
        title='Settings',
    )


class OrgMemberReadWithGrants(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the account member', title='Id')
    email: EmailStr = Field(
        ..., description='Email of the user controlling this account', title='Email'
    )
    email_verified: bool = Field(
        ...,
        description="Whether this email address is verified or not. For social providers like 'Login with Google' this is done automatically, otherwise we will send the user a verification link in email.",
        title='Email Verified',
    )
    name: Optional[str] = Field(None, description='Name of this user', title='Name')
    given_name: Optional[str] = Field(
        None, description='First name of the user', title='Given Name'
    )
    family_name: Optional[str] = Field(
        None, description='Last name of the user', title='Family Name'
    )
    picture: Optional[str] = Field(
        None,
        description='URL to picture, photo, or avatar of the user that controls this account.',
        title='Picture',
    )
    is_superuser: bool = Field(
        ...,
        description='Whether or not this user has special access to permit.io organizations',
        title='Is Superuser',
    )
    is_onboarding: bool = Field(
        ...,
        description='Whether or not this user is currently onboarding, needs to be replaced by a user journey object',
        title='Is Onboarding',
    )
    onboarding_step: OnboardingStep = Field(
        ..., description='the step the user is currently going through in onboarding'
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the account member was created (ISO_8601 format).',
        title='Created At',
    )
    last_login: Optional[datetime] = Field(
        None,
        description='Last date and time this user logged in (ISO_8601 format).',
        title='Last Login',
    )
    last_ip: Optional[str] = Field(
        '0.0.0.0',
        description='Last IP address from which this user logged in.',
        title='Last Ip',
    )
    logins_count: Optional[int] = Field(
        0,
        description='Total number of logins this user has performed.',
        title='Logins Count',
    )
    identities: List[IdentityRead] = Field(..., title='Identities')
    invite: Optional[InviteRead] = None
    settings: Dict[str, Any] = Field(
        ...,
        description='Custom permit.io dashboard settings, such as preferred theme, etc.',
        title='Settings',
    )
    grants: List[Permission] = Field(..., title='Grants')


class OrgMemberRemovePermissions(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the account member', title='Id')
    permissions: List[Permission] = Field(..., title='Permissions')


class OrganizationRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the organization', title='Id')
    is_enterprise: bool = Field(
        ..., description='Is this an enterprise account?', title='Is Enterprise'
    )
    usage_limits: Optional[UsageLimits] = Field(
        default_factory=lambda: UsageLimits.parse_obj(
            {'mau': 1000, 'tenants': 20, 'billing_tier': 'free'}
        ),
        description='Usage limits for this organization',
        title='Usage Limits',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the organization was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the organization was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title='Name',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )


class OrganizationReadWithAPIKey(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the organization', title='Id')
    is_enterprise: bool = Field(
        ..., description='Is this an enterprise account?', title='Is Enterprise'
    )
    usage_limits: Optional[UsageLimits] = Field(
        default_factory=lambda: UsageLimits.parse_obj(
            {'mau': 1000, 'tenants': 20, 'billing_tier': 'free'}
        ),
        description='Usage limits for this organization',
        title='Usage Limits',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the organization was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the organization was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title='Name',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )
    api_key_id: Optional[UUID] = Field(None, title='Api Key Id')
    api_key_secret: Optional[str] = Field(None, title='Api Key Secret')


class OrganizationStats(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the organization (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the organization.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the organization', title='Id')
    is_enterprise: bool = Field(
        ..., description='Is this an enterprise account?', title='Is Enterprise'
    )
    usage_limits: Optional[UsageLimits] = Field(
        default_factory=lambda: UsageLimits.parse_obj(
            {'mau': 1000, 'tenants': 20, 'billing_tier': 'free'}
        ),
        description='Usage limits for this organization',
        title='Usage Limits',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the organization was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the organization was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    name: str = Field(
        ...,
        description="The name of the organization, usually it's your company's name.",
        title='Name',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )
    stats: OrganizationStatistics
    historical_usage: HistoricalUsage


class PaginatedResultAccessRequestRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[AccessRequestRead] = Field(
        ..., description='List of Access Requests', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultActivityLogEventRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ActivityLogEventRead] = Field(
        ..., description='List of Activity Log Events', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultElementsUserInviteRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ElementsUserInviteRead] = Field(
        ..., description='List of Elements User Invites', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultOperationApprovalList(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[OperationApprovalList] = Field(
        ..., description='List of Operation Approval Lists', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultRelationRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RelationRead] = Field(..., description='List of Relations', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultResourceInstanceRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ResourceInstanceRead] = Field(
        ..., description='List of Resource Instances', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultRoleAssignmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RoleAssignmentRead] = Field(
        ..., description='List of Role Assignments', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultTenantRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[TenantRead] = Field(..., description='List of Tenants', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PolicyRepoCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.',
        title='Key',
    )
    url: constr(regex=r'^(.+@)*([\w\d\.]+):(.*)?.git$') = Field(..., title='Url')
    main_branch_name: Optional[str] = Field('main', title='Main Branch Name')
    credentials: SSHAuthData
    activate_when_validated: Optional[bool] = Field(
        False,
        description='if you want to change your policy repository to this repo right after it is validated',
        title='Activate When Validated',
    )


class PolicyRepoRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the policy repo', title='Id')
    status: PolicyRepoStatus
    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the policy repo (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the policy repo.',
        title='Key',
    )
    url: constr(regex=r'^(.+@)*([\w\d\.]+):(.*)?.git$') = Field(..., title='Url')
    main_branch_name: Optional[str] = Field('main', title='Main Branch Name')
    credentials: SSHAuthDataRead
    activate_when_validated: Optional[bool] = Field(
        False,
        description='if you want to change your policy repository to this repo right after it is validated',
        title='Activate When Validated',
    )


class ProxyConfigCreate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Any = Field(
        ...,
        description='Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.',
        title='Secret',
    )
    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.',
        title='Key',
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title='Name',
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description='Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.',
        title='Mapping Rules',
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        'Bearer',
        description='Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.',
    )


class ProxyConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='Proxy Config is set to enable the Permit Proxy to make proxied requests as part of the Frontend AuthZ.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the proxy config', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the proxy config belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the proxy config belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the proxy config belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the proxy config was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the proxy config was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    secret: Any = Field(
        ...,
        description='Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.',
        title='Secret',
    )
    name: str = Field(
        ...,
        description="The name of the proxy config, for example: 'Stripe API'",
        title='Name',
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description='Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.',
        title='Mapping Rules',
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        'Bearer',
        description='Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.',
    )


class ProxyConfigUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    secret: Optional[Any] = Field(
        None,
        description='Proxy config secret is set to enable the Permit Proxy to make proxied requests to the backend service.',
        title='Secret',
    )
    name: Optional[str] = Field(
        None,
        description="The name of the proxy config, for example: 'Stripe API'",
        title='Name',
    )
    mapping_rules: Optional[List[MappingRule]] = Field(
        [],
        description='Proxy config mapping rules will include the rules that will be used to map the request to the backend service by a URL and a http method.',
        title='Mapping Rules',
    )
    auth_mechanism: Optional[AuthMechanism] = Field(
        'Bearer',
        description='Proxy config auth mechanism will define the authentication mechanism that will be used to authenticate the request.\n\nBearer injects the secret into the Authorization header as a Bearer token,\n\nBasic injects the secret into the Authorization header as a Basic user:password,\n\nHeaders injects plain headers into the request.',
    )


class RelationshipTupleRead(BaseModel):
    class Config:
        extra = Extra.allow

    subject: str = Field(
        ...,
        description='resource_key:resource_instance_key of the subject',
        title='Subject',
    )
    relation: str = Field(
        ..., description='key of the assigned relation', title='Relation'
    )
    object: str = Field(
        ...,
        description='resource_key:resource_instance_key of the object',
        title='Object',
    )
    id: UUID = Field(..., description='Unique id of the relationship tuple', title='Id')
    tenant: str = Field(
        ...,
        description='The tenant the relationship tuple is associated with',
        title='Tenant',
    )
    subject_id: UUID = Field(
        ..., description='Unique id of the subject', title='Subject Id'
    )
    relation_id: UUID = Field(
        ..., description='Unique id of the relation', title='Relation Id'
    )
    object_id: UUID = Field(
        ..., description='Unique id of the object', title='Object Id'
    )
    tenant_id: UUID = Field(
        ..., description='Unique id of the tenant', title='Tenant Id'
    )
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the relationship tuple belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the relationship tuple belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the relationship tuple belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the relationship tuple was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the relationship tuple was created (ISO_8601 format).',
        title='Updated At',
    )
    subject_details: Optional[ResourceInstanceBlockRead] = Field(
        None,
        description='The subject details of the relationship tuple',
        title='Subject Details',
    )
    relation_details: Optional[StrippedRelationBlockRead] = Field(
        None,
        description='The relation details of the relationship tuple',
        title='Relation Details',
    )
    object_details: Optional[ResourceInstanceBlockRead] = Field(
        None,
        description='The object details of the relationship tuple',
        title='Object Details',
    )
    tenant_details: Optional[TenantBlockRead] = Field(
        None,
        description='The tenant details of the relationship tuple',
        title='Tenant Details',
    )


class RemoteConfig(BaseModel):
    class Config:
        extra = Extra.allow

    opal_common: OPALCommon
    opal_client: OPALClient
    pdp: Optional[PdpValues] = Field({}, title='Pdp')
    context: PDPContext


class RoleAssignmentDetailedRead(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., description='Unique id of the role assignment', title='Id')
    role: RoleAssignmentRole = Field(
        ..., description='the role that is assigned', title='Role'
    )
    user: RoleAssignmentUser = Field(
        ..., description='the user the role is assigned to', title='User'
    )
    tenant: RoleAssignmentTenant = Field(
        ..., description='the tenant the role is associated with', title='Tenant'
    )
    resource_instance: Optional[RoleAssignmentResourceInstance] = None
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the role assignment belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the role assignment belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the role assignment belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the role assignment was created (ISO_8601 format).',
        title='Created At',
    )


class UserCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9|@+\-\._]+$') = Field(
        ...,
        description='A unique id by which Permit will identify the user for permission checks.',
        title='Key',
    )
    email: Optional[EmailStr] = Field(
        None,
        description='The email of the user. If synced, will be unique inside the environment.',
        title='Email',
    )
    first_name: Optional[str] = Field(
        None, description='First name of the user.', title='First Name'
    )
    last_name: Optional[str] = Field(
        None, description='Last name of the user.', title='Last Name'
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary user attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )
    role_assignments: Optional[List[UserRoleCreate]] = Field(
        None,
        description='List of roles to assign to the user in the environment.',
        title='Role Assignments',
    )


class UserCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title='Operations')


class UserInTenant(BaseModel):
    class Config:
        extra = Extra.allow

    tenant: str = Field(
        ...,
        description='The tenant key which the user is associated with',
        title='Tenant',
    )
    roles: List[str] = Field(
        ...,
        description='List of roles assigned to the user in that tenant',
        title='Roles',
    )
    status: UserStatus = Field(..., description='Whether the user has signed in or not')
    resource_instance_roles: Optional[List[UserResourceInstanceRole]] = Field(
        [], title='Resource Instance Roles'
    )


class UserRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A unique id by which Permit will identify the user for permission checks.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the user', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the user belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the user belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the user belongs to.',
        title='Environment Id',
    )
    associated_tenants: Optional[List[UserInTenant]] = Field(
        [], title='Associated Tenants'
    )
    roles: Optional[List[UserRole]] = Field([], title='Roles')
    created_at: datetime = Field(
        ...,
        description='Date and time when the user was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the user was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    email: Optional[EmailStr] = Field(
        None,
        description='The email of the user. If synced, will be unique inside the environment.',
        title='Email',
    )
    first_name: Optional[str] = Field(
        None, description='First name of the user.', title='First Name'
    )
    last_name: Optional[str] = Field(
        None, description='Last name of the user.', title='Last Name'
    )
    attributes: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary user attributes that will be used to enforce attribute-based access control policies.',
        title='Attributes',
    )


class UserReplaceBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[UserCreate] = Field(..., title='Operations')


class WebhookRead(BaseModel):
    class Config:
        extra = Extra.allow

    type: WebhookType
    id: UUID = Field(..., description='Unique id of the webhook', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the webhook belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the webhook belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the webhook belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the webhook was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the webhook was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    url: str = Field(..., description='The url to POST the webhook to', title='Url')


class AuditLogModel(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    raw_data: Optional[
        Union[OPAEngineDecisionLog, AVPEngineDecisionLog, DummyEngineModel]
    ] = Field(None, title='Raw Data')
    timestamp: datetime = Field(..., title='Timestamp')
    created_at: Optional[datetime] = Field(None, title='Created At')
    query: Optional[str] = Field(None, title='Query')
    user_key: Optional[str] = Field(None, title='User Key')
    user_email: Optional[str] = Field(None, title='User Email')
    user_name: Optional[str] = Field(None, title='User Name')
    resource_type: Optional[str] = Field(None, title='Resource Type')
    tenant: Optional[str] = Field(None, title='Tenant')
    action: Optional[str] = Field(None, title='Action')
    decision: Optional[bool] = Field(None, title='Decision')
    reason: Optional[str] = Field(None, title='Reason')
    org_id: UUID = Field(..., title='Org Id')
    project_id: UUID = Field(..., title='Project Id')
    env_id: UUID = Field(..., title='Env Id')
    pdp_config_id: UUID = Field(..., title='Pdp Config Id')
    input: Optional[Any] = Field(None, title='Input')
    result: Optional[Any] = Field(None, title='Result')
    context: Optional[Any] = Field(None, title='Context')


class DataSourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    entries: Optional[List[DataSourceEntryWithPollingInterval]] = Field(
        [],
        description='list of data sources and how to fetch from them',
        title='Entries',
    )


class DerivedRole(BaseModel):
    class Config:
        extra = Extra.allow

    conditions: Optional[str] = Field(None, title='Conditions')
    settings: PermitBackendSchemasSchemaOpalDataDerivationSettings = Field(
        ..., description='Settings for the derived role.', title='Settings'
    )
    rules: List[DerivedRoleRule] = Field(
        ..., description='List of rules for the derived role.', title='Rules'
    )


class DerivedRoleBlockEdit(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings.parse_obj(
            {'no_direct_roles_on_object': False}
        ),
        description='the settings of the derived role',
        title='When',
    )
    users_with_role: Optional[List[DerivedRoleRuleCreate]] = Field(
        [], description='the rules of the derived role', title='Users With Role'
    )


class DerivedRoleBlockRead(BaseModel):
    class Config:
        extra = Extra.allow

    when: Optional[PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings] = Field(
        default_factory=lambda: PermitBackendSchemasSchemaDerivedRoleRuleDerivationSettings.parse_obj(
            {'no_direct_roles_on_object': False}
        ),
        description='the settings of the derived role',
        title='When',
    )
    id: UUID = Field(..., description='The unique id of the derived_role', title='Id')
    users_with_role: Optional[List[DerivedRoleRuleRead]] = Field(
        [], description='the rules of the derived role', title='Users With Role'
    )


class DetailedAuditLogModel(BaseModel):
    class Config:
        extra = Extra.allow

    id: UUID = Field(..., title='Id')
    raw_data: Union[OPAEngineDecisionLog, AVPEngineDecisionLog, DummyEngineModel] = (
        Field(..., title='Raw Data')
    )
    timestamp: datetime = Field(..., title='Timestamp')
    created_at: Optional[datetime] = Field(None, title='Created At')
    query: Optional[str] = Field(None, title='Query')
    user_key: Optional[str] = Field(None, title='User Key')
    user_email: Optional[str] = Field(None, title='User Email')
    user_name: Optional[str] = Field(None, title='User Name')
    resource_type: Optional[str] = Field(None, title='Resource Type')
    tenant: Optional[str] = Field(None, title='Tenant')
    action: Optional[str] = Field(None, title='Action')
    decision: Optional[bool] = Field(None, title='Decision')
    reason: Optional[str] = Field(None, title='Reason')
    org_id: UUID = Field(..., title='Org Id')
    project_id: UUID = Field(..., title='Project Id')
    env_id: UUID = Field(..., title='Env Id')
    pdp_config_id: UUID = Field(..., title='Pdp Config Id')
    input: Optional[Any] = Field(None, title='Input')
    result: Optional[Any] = Field(None, title='Result')
    context: Optional[Any] = Field(None, title='Context')
    objects: AuditLogObjectsModel


class ElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the elements_config (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the elements_config.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the elements_config', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the elements_config belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the elements_config belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the elements_config belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the elements_config was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the elements_config was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    is_active: bool = Field(..., title='Is Active')
    name: str = Field(..., description='The name of the elements_config', title='Name')
    elements_type: ElementsType = Field(
        ..., description='The type of the elements interface, e.g: user management'
    )
    settings: Dict[str, Union[int, str, bool]] = Field(
        ...,
        description='Obj with the options of the elements interface, e.g: primary color',
        title='Settings',
    )
    email_notifications: Optional[bool] = Field(
        False,
        description='Whether to send email notifications to users using your Email Provider you set',
        title='Email Notifications',
    )
    roles_to_levels: Dict[str, List[PermissionLevelRoleRead]] = Field(
        ...,
        description='Obj with levels as keys and role ids as values',
        title='Roles To Levels',
    )
    webhook: Optional[WebhookRead] = None


class ElementsConfigRuntimeRead(BaseModel):
    class Config:
        extra = Extra.allow

    config: ElementsConfigRead
    current_permission_level: ElementsPermissionLevel


class EnvironmentCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.',
        title='Key',
    )
    name: str = Field(..., description='The name of the environment', title='Name')
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the environment',
        title='Description',
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description='when using gitops feature, an optional branch name for the environment',
        title='Custom Branch Name',
    )
    jwks: Optional[JwksConfig] = Field(
        None, description='jwks for element frontend only login', title='Jwks'
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this environment', title='Settings'
    )


class EnvironmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the environment', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the environment belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the environment belongs to.',
        title='Project Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the environment was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the environment was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    avp_policy_store_id: Optional[str] = Field(None, title='Avp Policy Store Id')
    name: str = Field(..., description='The name of the environment', title='Name')
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the environment',
        title='Description',
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description='when using gitops feature, an optional branch name for the environment',
        title='Custom Branch Name',
    )
    jwks: Optional[JwksConfig] = Field(
        None, description='jwks for element frontend only login', title='Jwks'
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this environment', title='Settings'
    )


class EnvironmentReadWithEmailConfig(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the environment', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the environment belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the environment belongs to.',
        title='Project Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the environment was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the environment was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    avp_policy_store_id: Optional[str] = Field(None, title='Avp Policy Store Id')
    name: str = Field(..., description='The name of the environment', title='Name')
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the environment',
        title='Description',
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description='when using gitops feature, an optional branch name for the environment',
        title='Custom Branch Name',
    )
    jwks: Optional[JwksConfig] = Field(
        None, description='jwks for element frontend only login', title='Jwks'
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this environment', title='Settings'
    )
    email_configuration: UUID = Field(..., title='Email Configuration')


class EnvironmentStatistics(BaseModel):
    class Config:
        extra = Extra.allow

    roles: conint(ge=0) = Field(..., title='Roles')
    users: conint(ge=0) = Field(..., title='Users')
    policies: conint(ge=0) = Field(..., title='Policies')
    resources: conint(ge=0) = Field(..., title='Resources')
    tenants: conint(ge=0) = Field(..., title='Tenants')
    has_decision_logs: bool = Field(..., title='Has Decision Logs')
    members: List[OrgMemberReadWithGrants] = Field(..., title='Members')
    mau: conint(ge=0) = Field(..., title='Mau')


class EnvironmentStats(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the environment (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the environment.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the environment', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the environment belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the environment belongs to.',
        title='Project Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the environment was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the environment was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    avp_policy_store_id: Optional[str] = Field(None, title='Avp Policy Store Id')
    name: str = Field(..., description='The name of the environment', title='Name')
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the environment',
        title='Description',
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description='when using gitops feature, an optional branch name for the environment',
        title='Custom Branch Name',
    )
    jwks: Optional[JwksConfig] = Field(
        None, description='jwks for element frontend only login', title='Jwks'
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this environment', title='Settings'
    )
    pdp_configs: List[PDPConfigRead] = Field(..., title='Pdp Configs')
    stats: EnvironmentStatistics


class EnvironmentUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the environment', title='Name'
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the environment',
        title='Description',
    )
    custom_branch_name: Optional[str] = Field(
        None,
        description='when using gitops feature, an optional branch name for the environment',
        title='Custom Branch Name',
    )
    jwks: Optional[JwksConfig] = Field(
        None, description='jwks for element frontend only login', title='Jwks'
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this environment', title='Settings'
    )


class LimitedPaginatedResultAuditLogModel(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[AuditLogModel] = Field(
        ..., description='List of Audit Log Models', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')
    pagination_count: conint(ge=0) = Field(..., title='Pagination Count')


class PaginatedResultElementsConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ElementsConfigRead] = Field(
        ..., description='List of Elements Configs', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultRelationshipTupleRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RelationshipTupleRead] = Field(
        ..., description='List of Relationship Tuples', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultRoleAssignmentDetailedRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RoleAssignmentDetailedRead] = Field(
        ..., description='List of Role Assignment Detaileds', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultUserRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[UserRead] = Field(..., description='List of Users', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class ProjectCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the project (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the project.',
        title='Key',
    )
    urn_namespace: Optional[constr(regex=r'[a-z0-9-]{2,}')] = Field(
        None,
        description='Optional namespace for URNs. If empty, URNs will be generated from project key.',
        title='Urn Namespace',
    )
    name: str = Field(..., description='The name of the project', title='Name')
    description: Optional[str] = Field(
        None,
        description='a longer description outlining the project objectives',
        title='Description',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None, description='the settings for this project', title='Settings'
    )
    active_policy_repo_id: Optional[UUID] = Field(
        None,
        description='the id of the policy repo to use for this project',
        title='Active Policy Repo Id',
    )
    initial_environments: Optional[List[EnvironmentCreate]] = Field(
        default_factory=lambda: [
            EnvironmentCreate.parse_obj(v)
            for v in [
                {'key': 'dev', 'name': 'Development'},
                {'key': 'production', 'name': 'Production'},
            ]
        ],
        description="The initial environments to create for this project. By default, 'Development' and 'Production' are created, specify [] (empty list) to skip that.",
        title='Initial Environments',
    )


class ResourceRoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.',
        title='Key',
    )
    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )


class ResourceRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        [],
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    key: str = Field(
        ...,
        description='A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the role', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the role belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the role belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the role belongs to.',
        title='Environment Id',
    )
    resource_id: UUID = Field(
        ...,
        description='Unique id of the resource that the role belongs to.',
        title='Resource Id',
    )
    resource: str = Field(
        ...,
        description='The unique resource key that the role belongs to.',
        title='Resource',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the role was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the role was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class ResourceRoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        [],
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )


class ResourceTypeData(BaseModel):
    class Config:
        extra = Extra.allow

    actions: List[str] = Field(
        ...,
        description='List of actions that can be performed on the resource.',
        title='Actions',
    )
    derived_roles: Dict[str, DerivedRole] = Field(
        ...,
        description='Key-Value mapping of the derived roles for the resource type.\nThe key is the derived role key and the value is the details and conditions for the role derivation.',
        title='Derived Roles',
    )


class RoleBlockEditable(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )


class RoleCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.',
        title='Key',
    )
    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )
    v1compat_is_built_in: Optional[bool] = Field(None, title='V1Compat Is Built In')


class RoleCreateBulk(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )
    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the Role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the Role.',
        title='Key',
    )
    resource: Optional[str] = Field(
        None,
        description='The resource key for the role. Optional; for tenant roles, leave empty.',
        title='Resource',
    )


class RoleCreateBulkOperation(BaseModel):
    class Config:
        extra = Extra.allow

    operations: List[RoleCreateBulk] = Field(..., title='Operations')


class RoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockRead] = Field(
        {},
        description='\n        A derived role defintion block, typically contained whithin a role definition.\n        The derived role is a role that is derived from the role definition.\n        ',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )
    key: str = Field(
        ...,
        description='A URL-friendly name of the role (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the role.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the role', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the role belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the role belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the role belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the role was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the role was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class RoleUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(None, description='The name of the role', title='Name')
    description: Optional[str] = Field(
        None,
        description='optional description string explaining what this role represents, or what permissions are granted to it.',
        title='Description',
    )
    permissions: Optional[List[str]] = Field(
        None,
        description='list of action keys that define what actions this resource role is permitted to do',
        title='Permissions',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="optional dictionary of key-value pairs that can be used to store arbitrary metadata about this role. This metadata can be used to filter role using query parameters with attr_ prefix, currently supports only 'equals' operator",
        title='Attributes',
    )
    extends: Optional[List[str]] = Field(
        None,
        description='list of role keys that define what roles this role extends. In other words: this role will automatically inherit all the permissions of the given roles in this list.',
        title='Extends',
    )
    granted_to: Optional[DerivedRoleBlockEdit] = Field(
        None,
        description='Derived role that inherit will be applied on this role',
        title='Granted To',
    )
    v1compat_settings: Optional[Dict[str, Any]] = Field(None, title='V1Compat Settings')
    v1compat_attributes: Optional[Dict[str, Any]] = Field(
        None, title='V1Compat Attributes'
    )


class ScopeConfigRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[DataSourceConfig] = None
    id: UUID = Field(..., description='Unique id of the ScopeConfig', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the ScopeConfig belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the ScopeConfig belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the ScopeConfig belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the ScopeConfig was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the ScopeConfig was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )


class ScopeConfigSet(BaseModel):
    class Config:
        extra = Extra.allow

    data: Optional[DataSourceConfig] = None


class TaskResultEnvironmentRead(BaseModel):
    class Config:
        extra = Extra.allow

    task_id: str = Field(..., description='The unique id of the task.', title='Task Id')
    status: TaskStatus = Field(..., description='The status of the task.')
    result: Optional[EnvironmentRead] = Field(
        None,
        description='The result of the task when the task finished.',
        title='Result',
    )
    error: Optional[ErrorDetails] = Field(
        None, description='The error details when the task failed.', title='Error'
    )


class APIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    organization_id: UUID = Field(..., title='Organization Id')
    project_id: Optional[UUID] = Field(None, title='Project Id')
    environment_id: Optional[UUID] = Field(None, title='Environment Id')
    object_type: Optional[MemberAccessObj] = 'env'
    access_level: Optional[MemberAccessLevel] = 'admin'
    owner_type: APIKeyOwnerType
    name: Optional[str] = Field(None, title='Name')
    id: UUID = Field(..., title='Id')
    secret: Optional[str] = Field(None, title='Secret')
    created_at: datetime = Field(..., title='Created At')
    created_by_member: Optional[OrgMemberRead] = None
    last_used_at: Optional[datetime] = Field(None, title='Last Used At')
    env: Optional[EnvironmentRead] = None
    project: Optional[ProjectRead] = None


class EnvironmentCopyTarget(BaseModel):
    class Config:
        extra = Extra.allow

    existing: Optional[str] = Field(
        None,
        description='Identifier of an existing environment to copy into',
        title='Existing',
    )
    new: Optional[EnvironmentCreate] = Field(
        None,
        description='Description of the environment to create. This environment must not already exist.',
        title='New',
    )


class FullData(BaseModel):
    class Config:
        extra = Extra.allow

    use_debugger: Optional[bool] = Field(True, title='Use Debugger')
    users: Dict[str, UserData] = Field(
        ...,
        description='Key-Value mapping of the users in the system.\nThe key is the user key and the value contains some details about the user.',
        title='Users',
    )
    tenants: Dict[str, TenantData] = Field(
        ...,
        description='Key-Value mapping of the tenants in the system.\nThe key is the tenant key and the value contains some details about the tenant.',
        title='Tenants',
    )
    roles: Dict[str, RoleData] = Field(
        ...,
        description='Key-Value mapping of the roles in the system.\nThe key is the role key and the value contains some details about the role.',
        title='Roles',
    )
    condition_set_rules: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ...,
        description='Key-Value mapping of the permissions for each condition set.\nThe key is the user-set key and the value is Key-Value mapping of resource-set key to the permissions for that user-set & resource-set.The key is the resource key and the value is list of actions that the user-set can perform on that resource-set',
        title='Condition Set Rules',
    )
    relationships: Dict[str, Dict[str, Dict[str, List[str]]]] = Field(
        ...,
        description='Key-Value mapping of the relationships between resources.\nThe key is the resource instance key and the value is Key-Value mapping of relation key to a Key-Value mapping of resource ( type ) to list of instances keys.',
        title='Relationships',
    )
    resource_types: Dict[str, ResourceTypeData] = Field(
        ...,
        description='Key-Value mapping of the resource types in the system.\nThe key is the resource type key and the value contains some details about the resource type.',
        title='Resource Types',
    )
    condition_sets: Dict[str, ConditionSetData] = Field(
        ...,
        description='Key-Value mapping of the condition sets in the system.\nThe key is the formatted condition set key and the value contains some details about the condition set.',
        title='Condition Sets',
    )
    role_assignments: Dict[str, Dict[str, List[str]]] = Field(
        ...,
        description='Key-Value mapping of the role assignments for the users.\nThe key is the user key and the value is Key-Value mapping of resource instance key or tenant key to list of role keys assigned to the user in that resource instance.',
        title='Role Assignments',
    )
    role_permissions: Dict[str, Dict[str, RoleData]] = Field(
        ...,
        description='Key-Value mapping of the permissions for each role.\nThe key is the resource key and the value is Key-Value mapping of role key to details on the role permissions.',
        title='Role Permissions',
    )
    mapping_rules: Optional[Dict[str, List[Dict[str, Union[str, int]]]]] = Field(
        {},
        description="Key-Value mapping of groups of mapping rules in the system.\nThe key is the mapping rule group and the value is a list of mapping rules objects.We currently have only one group named 'all' which contains all the mapping rules.A mapping rule object contains, action, http_method, resource and url - all strings.",
        title='Mapping Rules',
    )
    resource_instances: Optional[Dict[str, ResourceInstanceAttributeData]] = Field(
        {},
        description='Key-Value mapping of the resource instances in the system.\nThe key is the resource instance key and the value contains some details about the resource instance.',
        title='Resource Instances',
    )


class PaginatedResultAPIKeyRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[APIKeyRead] = Field(..., description='List of Api Keys', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultResourceRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ResourceRoleRead] = Field(
        ..., description='List of Resource Roles', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultRoleRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[RoleRead] = Field(..., description='List of Roles', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class ResourceCreate(BaseModel):
    class Config:
        extra = Extra.allow

    key: constr(regex=r'^[A-Za-z0-9\-_]+$') = Field(
        ...,
        description='A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.',
        title='Key',
    )
    name: str = Field(..., description='The name of the resource', title='Name')
    urn: Optional[str] = Field(
        None,
        description='The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource',
        title='Urn',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this resource respresents in your system',
        title='Description',
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description='\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ',
        title='Actions',
    )
    type_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this resource. This metadata can be used to filter resource using query parameters with attr_ prefix',
        title='Type Attributes',
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description='Attributes that each resource of this type defines, and can be used in your ABAC policies.',
        title='Attributes',
    )
    roles: Optional[Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), RoleBlockEditable]] = (
        Field(
            None,
            description='Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.',
            title='Roles',
        )
    )
    relations: Optional[
        Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), constr(regex=r'^[A-Za-z0-9\-_]+$')]
    ] = Field(
        None,
        description='Relations to other resources. The key is the relation key, and the value is the related resource.',
        title='Relations',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_type: Optional[str] = Field(None, title='V1Compat Type')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class ResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A URL-friendly name of the resource (i.e: slug). You will be able to query later using this key instead of the id (UUID) of the resource.',
        title='Key',
    )
    id: UUID = Field(..., description='Unique id of the resource', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the resource belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the resource belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the resource belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the resource was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the resource was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    name: str = Field(..., description='The name of the resource', title='Name')
    urn: Optional[str] = Field(
        None,
        description='The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource',
        title='Urn',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this resource respresents in your system',
        title='Description',
    )
    actions: Optional[Dict[str, ActionBlockRead]] = Field(
        {},
        description='\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ',
        title='Actions',
    )
    type_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this resource. This metadata can be used to filter resource using query parameters with attr_ prefix',
        title='Type Attributes',
    )
    attributes: Optional[Dict[str, AttributeBlockRead]] = Field(
        None,
        description='Attributes that each resource of this type defines, and can be used in your ABAC policies.',
        title='Attributes',
    )
    roles: Optional[Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), ResourceRoleRead]] = Field(
        None,
        description='Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, etc.',
        title='Roles',
    )
    relations: Optional[Dict[str, RelationBlockRead]] = Field(
        {},
        description='\n        A relations definition block, typically contained within a resource type definition block.\n        The relations represents the ways you can interact with a protected resource.\n        ',
        title='Relations',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_type: Optional[str] = Field(None, title='V1Compat Type')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')
    action_groups: Optional[Dict[str, List[str]]] = Field({}, title='Action Groups')


class ResourceReplace(BaseModel):
    class Config:
        extra = Extra.allow

    name: str = Field(..., description='The name of the resource', title='Name')
    urn: Optional[str] = Field(
        None,
        description='The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource',
        title='Urn',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this resource respresents in your system',
        title='Description',
    )
    actions: Dict[str, ActionBlockEditable] = Field(
        ...,
        description='\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ',
        title='Actions',
    )
    type_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this resource. This metadata can be used to filter resource using query parameters with attr_ prefix',
        title='Type Attributes',
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description='Attributes that each resource of this type defines, and can be used in your ABAC policies.',
        title='Attributes',
    )
    roles: Optional[Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), RoleBlockEditable]] = (
        Field(
            None,
            description='Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.',
            title='Roles',
        )
    )
    relations: Optional[
        Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), constr(regex=r'^[A-Za-z0-9\-_]+$')]
    ] = Field(
        None,
        description='Relations to other resources. The key is the relation key, and the value is the related resource.',
        title='Relations',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_type: Optional[str] = Field(None, title='V1Compat Type')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class ResourceRoleList(BaseModel):
    class Config:
        extra = Extra.allow

    roles: Union[List[ResourceRoleRead], PaginatedResultResourceRoleRead] = Field(
        ..., title='Roles'
    )


class ResourceUpdate(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = Field(
        None, description='The name of the resource', title='Name'
    )
    urn: Optional[str] = Field(
        None,
        description='The [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (Uniform Resource Name) of the resource',
        title='Urn',
    )
    description: Optional[str] = Field(
        None,
        description='An optional longer description of what this resource respresents in your system',
        title='Description',
    )
    actions: Optional[Dict[str, ActionBlockEditable]] = Field(
        None,
        description='\n        A actions definition block, typically contained within a resource type definition block.\n        The actions represents the ways you can interact with a protected resource.\n        ',
        title='Actions',
    )
    type_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='optional dictionary of key-value pairs that can be used to store arbitrary metadata about this resource. This metadata can be used to filter resource using query parameters with attr_ prefix',
        title='Type Attributes',
    )
    attributes: Optional[Dict[str, AttributeBlockEditable]] = Field(
        None,
        description='Attributes that each resource of this type defines, and can be used in your ABAC policies.',
        title='Attributes',
    )
    roles: Optional[Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), RoleBlockEditable]] = (
        Field(
            None,
            description='Roles defined on this resource. The key is the role name, and the value contains the role properties such as granted permissions, base roles, etc.',
            title='Roles',
        )
    )
    relations: Optional[
        Dict[constr(regex=r'^[A-Za-z0-9\-_]+$'), constr(regex=r'^[A-Za-z0-9\-_]+$')]
    ] = Field(
        None,
        description='Relations to other resources. The key is the relation key, and the value is the related resource.',
        title='Relations',
    )
    v1compat_path: Optional[str] = Field(None, title='V1Compat Path')
    v1compat_type: Optional[str] = Field(None, title='V1Compat Type')
    v1compat_name: Optional[str] = Field(None, title='V1Compat Name')


class RoleList(BaseModel):
    class Config:
        extra = Extra.allow

    roles: Union[List[RoleRead], PaginatedResultRoleRead] = Field(..., title='Roles')


class ConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    key: str = Field(
        ...,
        description='A unique id by which Permit will identify the condition set. The key will be used as the generated rego rule name.',
        title='Key',
    )
    type: Optional[ConditionSetType] = Field(
        'userset', description='the type of the set: UserSet or ResourceSet'
    )
    autogenerated: Optional[bool] = Field(
        False,
        description='whether the set was autogenerated by the system.',
        title='Autogenerated',
    )
    resource_id: Optional[Union[str, UUID]] = Field(
        None,
        description='For ResourceSets, the id of the base resource.',
        title='Resource Id',
    )
    id: UUID = Field(..., description='Unique id of the condition set', title='Id')
    organization_id: UUID = Field(
        ...,
        description='Unique id of the organization that the condition set belongs to.',
        title='Organization Id',
    )
    project_id: UUID = Field(
        ...,
        description='Unique id of the project that the condition set belongs to.',
        title='Project Id',
    )
    environment_id: UUID = Field(
        ...,
        description='Unique id of the environment that the condition set belongs to.',
        title='Environment Id',
    )
    created_at: datetime = Field(
        ...,
        description='Date and time when the condition set was created (ISO_8601 format).',
        title='Created At',
    )
    updated_at: datetime = Field(
        ...,
        description='Date and time when the condition set was last updated/modified (ISO_8601 format).',
        title='Updated At',
    )
    resource: Optional[ResourceRead] = None
    name: str = Field(
        ...,
        description="A descriptive name for the set, i.e: 'US based employees' or 'Users behind VPN'",
        title='Name',
    )
    description: Optional[str] = Field(
        None,
        description='an optional longer description of the set',
        title='Description',
    )
    conditions: Optional[Dict[str, Any]] = Field(
        {},
        description='a boolean expression that consists of multiple conditions, with and/or logic.',
        title='Conditions',
    )
    parent_id: Optional[Union[str, UUID]] = Field(
        None, description='Parent Condition Set', title='Parent Id'
    )


class EnvironmentCopy(BaseModel):
    class Config:
        extra = Extra.allow

    target_env: EnvironmentCopyTarget = Field(
        ...,
        description='If copying a new environment, the environment configuration. If copying to an existing environment, the environment identifier',
        title='Target Env',
    )
    conflict_strategy: Optional[EnvironmentCopyConflictStrategy] = Field(
        'fail',
        description='Action to take when detecting a conflict when copying. Only applies to copying into an existing environment',
    )
    scope: Optional[EnvironmentCopyScope] = Field(
        default_factory=lambda: EnvironmentCopyScope.parse_obj(
            {
                'resources': {'include': [], 'exclude': []},
                'roles': {'include': [], 'exclude': []},
                'user_sets': {'include': [], 'exclude': []},
                'resource_sets': {'include': [], 'exclude': []},
                'custom_policies': {'include': [], 'exclude': []},
            }
        ),
        description='Filters to include and exclude copied objects',
        title='Scope',
    )


class PaginatedResultConditionSetRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ConditionSetRead] = Field(
        ..., description='List of Condition Sets', title='Data'
    )
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')


class PaginatedResultResourceRead(BaseModel):
    class Config:
        extra = Extra.allow

    data: List[ResourceRead] = Field(..., description='List of Resources', title='Data')
    total_count: conint(ge=0) = Field(..., title='Total Count')
    page_count: Optional[conint(ge=0)] = Field(0, title='Page Count')
